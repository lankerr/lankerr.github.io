<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ROS_算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/22/ROS_%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-03-21T21:32:41.482Z" itemprop="datePublished">2025-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ROS常见算法汇总"><a href="#ROS常见算法汇总" class="headerlink" title="ROS常见算法汇总"></a>ROS常见算法汇总</h1><h2 id="长期-dijkstra"><a href="#长期-dijkstra" class="headerlink" title="长期-dijkstra"></a>长期-dijkstra</h2><h1 id="Dijkstra算法在ROS中的实现"><a href="#Dijkstra算法在ROS中的实现" class="headerlink" title="Dijkstra算法在ROS中的实现"></a>Dijkstra算法在ROS中的实现</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>Dijkstra算法是一种经典的图论算法，用于寻找图中从源点到其他所有顶点的最短路径。在ROS（机器人操作系统）中，Dijkstra算法常用于路径规划模块，为机器人提供在环境中的最优路径。</p>
<h3 id="核心数学变量定义"><a href="#核心数学变量定义" class="headerlink" title="核心数学变量定义"></a>核心数学变量定义</h3><ul>
<li><strong>G(V, E)</strong>: 表示一个图，V为顶点集合，E为边集合</li>
<li><strong>s</strong>: 源顶点，路径的起始点</li>
<li><strong>d[v]</strong>: 从源点s到顶点v的最短距离估计值</li>
<li><strong>π[v]</strong>: 前驱节点，记录从s到v的最短路径上v的前一个顶点</li>
<li><strong>Q</strong>: 优先队列，存储待处理的顶点</li>
<li><strong>S</strong>: 已处理完毕的顶点集合</li>
<li><strong>w(u,v)</strong>: 边(u,v)的权重，表示从顶点u到顶点v的代价</li>
</ul>
<h2 id="2-基本思路与核心数学公式"><a href="#2-基本思路与核心数学公式" class="headerlink" title="2. 基本思路与核心数学公式"></a>2. 基本思路与核心数学公式</h2><h3 id="寻宝之旅：Dijkstra算法的形象比喻"><a href="#寻宝之旅：Dijkstra算法的形象比喻" class="headerlink" title="寻宝之旅：Dijkstra算法的形象比喻"></a>寻宝之旅：Dijkstra算法的形象比喻</h3><p>想象你是一位探险家，站在迷宫入口（源点s），手持一盏能照亮周围道路的魔法灯（Dijkstra算法）。你的目标是找到从入口到各个宝藏房间（其他顶点）的最短路径。</p>
<ol>
<li><p><strong>初始化阶段</strong>：你站在入口，灯光刚亮起（d[s]&#x3D;0），所有其他房间都隐藏在黑暗中（d[v]&#x3D;∞，v≠s）。你有一本笔记本，准备记录从入口到每个房间的最短距离和路线。</p>
</li>
<li><p><strong>探索阶段</strong>：在每一步中，你选择当前已知距离最短的未探索房间（从Q中提取最小d[u]的顶点u）。你走到这个房间，把它标记为”已探索”（加入集合S），然后观察从这个房间能直接到达的所有相邻房间（邻接点v）。</p>
</li>
<li><p><strong>更新阶段</strong>：对于每个相邻房间v，你计算从入口经过当前房间u再到v的总距离（d[u] + w(u,v)）。如果这条新路径比你之前记录的路径更短（d[u] + w(u,v) &lt; d[v]），那么你就更新笔记本上v的记录：新的最短距离和新的前一个房间。</p>
</li>
<li><p><strong>重复探索</strong>：不断重复这个过程，直到所有房间都被探索完毕（Q为空）。</p>
</li>
</ol>
<h3 id="核心数学公式"><a href="#核心数学公式" class="headerlink" title="核心数学公式"></a>核心数学公式</h3><ol>
<li><p><strong>初始化</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d[s] = 0</span><br><span class="line">d[v] = ∞, ∀v ∈ V-&#123;s&#125;</span><br><span class="line">π[v] = NULL, ∀v ∈ V</span><br><span class="line">Q = V (所有顶点)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>松弛操作</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RELAX(u, v, w):</span><br><span class="line">  if d[v] &gt; d[u] + w(u,v)</span><br><span class="line">    then d[v] = d[u] + w(u,v)</span><br><span class="line">         π[v] = u</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>主算法</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DIJKSTRA(G, w, s):</span><br><span class="line">  INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">  S = ∅</span><br><span class="line">  Q = V</span><br><span class="line">  while Q ≠ ∅</span><br><span class="line">    u = EXTRACT-MIN(Q)  // 提取d值最小的顶点</span><br><span class="line">    S = S ∪ &#123;u&#125;</span><br><span class="line">    for each vertex v ∈ Adj[u]</span><br><span class="line">      RELAX(u, v, w)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-数学推导"><a href="#3-数学推导" class="headerlink" title="3. 数学推导"></a>3. 数学推导</h2><p>Dijkstra算法的核心思想是贪心法，即每次都选择当前已知的最短路径进行扩展。以下是对算法正确性的严密推导：</p>
<h3 id="引理1：松弛不变式"><a href="#引理1：松弛不变式" class="headerlink" title="引理1：松弛不变式"></a>引理1：松弛不变式</h3><ul>
<li>对于所有顶点v∈V，d[v]始终是从s到v的某条路径的长度，且d[v]≥δ(s,v)，其中δ(s,v)是从s到v的真实最短路径长度。</li>
<li>一旦d[v]&#x3D;δ(s,v)，则d[v]的值不再改变。</li>
</ul>
<h3 id="引理2：上界不变式"><a href="#引理2：上界不变式" class="headerlink" title="引理2：上界不变式"></a>引理2：上界不变式</h3><ul>
<li>对于所有顶点v∈V，d[v]≥δ(s,v)，且这个不等式在算法执行过程中始终保持。</li>
</ul>
<h3 id="引理3：松弛最短路径"><a href="#引理3：松弛最短路径" class="headerlink" title="引理3：松弛最短路径"></a>引理3：松弛最短路径</h3><ul>
<li>如果从s到v的最短路径为p&#x3D;⟨s, v₁, v₂, …, vₖ, v⟩，且在某一时刻对于p上的所有边(vᵢ, vᵢ₊₁)都进行了松弛操作，且松弛顺序与路径顺序一致，则d[v]&#x3D;δ(s,v)。</li>
</ul>
<h3 id="定理：Dijkstra算法的正确性"><a href="#定理：Dijkstra算法的正确性" class="headerlink" title="定理：Dijkstra算法的正确性"></a>定理：Dijkstra算法的正确性</h3><p>当算法终止时，对于所有顶点v∈V，有d[v]&#x3D;δ(s,v)。</p>
<p><strong>证明</strong>：</p>
<ol>
<li>将顶点集V分为两部分：已处理的顶点集S和未处理的顶点集Q&#x3D;V-S。</li>
<li>假设u是从Q中提取的顶点，则有d[u]&#x3D;δ(s,u)（最小路径估计等于真实最短路径长度）。</li>
<li>归纳假设：对于所有已经加入S的顶点v，都有d[v]&#x3D;δ(s,v)。</li>
<li>基本情况：当S&#x3D;{s}时，显然d[s]&#x3D;0&#x3D;δ(s,s)，归纳假设成立。</li>
<li>归纳步骤：假设对于当前S中的所有顶点，归纳假设都成立。现在从Q中提取具有最小d值的顶点u。</li>
<li>反证法：假设d[u]≠δ(s,u)，由于d[u]≥δ(s,u)（引理2），所以d[u]&gt;δ(s,u)。</li>
<li>考虑从s到u的真实最短路径p，必然存在一个顶点y，它是p上第一个属于Q的顶点（因为u∈Q）。设y之前的顶点为x，则x∈S。</li>
<li>由归纳假设，d[x]&#x3D;δ(s,x)。当x被加入S时，对边(x,y)进行了松弛操作，因此d[y]&#x3D;δ(s,y)。</li>
<li>由于δ(s,y)≤δ(s,u)（y在从s到u的最短路径上），且u是Q中d值最小的顶点，所以d[u]≤d[y]&#x3D;δ(s,y)≤δ(s,u)。</li>
<li>这与我们的假设d[u]&gt;δ(s,u)矛盾。</li>
<li>因此，d[u]&#x3D;δ(s,u)，归纳假设对新的集合S∪{u}仍然成立。</li>
<li>当算法终止时，S&#x3D;V，因此对于所有顶点v∈V，都有d[v]&#x3D;δ(s,v)。</li>
</ol>
<p>因此，Dijkstra算法在终止时成功找到了从源点s到图中所有顶点的最短路径。</p>
<h2 id="4-ROS源码实现"><a href="#4-ROS源码实现" class="headerlink" title="4. ROS源码实现"></a>4. ROS源码实现</h2><p>以下是在ROS中实现Dijkstra算法的典型代码，用于机器人路径规划：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nav_msgs/OccupancyGrid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nav_msgs/Path.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/PoseStamped.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DijkstraPlanner</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 地图相关参数</span></span><br><span class="line">    nav_msgs::OccupancyGrid map_;</span><br><span class="line">    <span class="type">int</span> width_;</span><br><span class="line">    <span class="type">int</span> height_;</span><br><span class="line">    <span class="type">double</span> resolution_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ROS节点句柄和发布者</span></span><br><span class="line">    ros::NodeHandle nh_;</span><br><span class="line">    ros::Subscriber map_sub_;</span><br><span class="line">    ros::Publisher path_pub_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 起点和终点</span></span><br><span class="line">    geometry_msgs::PoseStamped start_;</span><br><span class="line">    geometry_msgs::PoseStamped goal_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方向数组，8个方向</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DijkstraPlanner</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化ROS节点</span></span><br><span class="line">        map_sub_ = nh_.<span class="built_in">subscribe</span>(<span class="string">&quot;/map&quot;</span>, <span class="number">1</span>, &amp;DijkstraPlanner::mapCallback, <span class="keyword">this</span>);</span><br><span class="line">        path_pub_ = nh_.<span class="built_in">advertise</span>&lt;nav_msgs::Path&gt;(<span class="string">&quot;/path&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收起点和终点参数</span></span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;start_x&quot;</span>, start_.pose.position.x, <span class="number">0.0</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;start_y&quot;</span>, start_.pose.position.y, <span class="number">0.0</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;goal_x&quot;</span>, goal_.pose.position.x, <span class="number">0.0</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;goal_y&quot;</span>, goal_.pose.position.y, <span class="number">0.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地图回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mapCallback</span><span class="params">(<span class="type">const</span> nav_msgs::OccupancyGrid::ConstPtr&amp; map)</span> </span>&#123;</span><br><span class="line">        map_ = *map;</span><br><span class="line">        width_ = map_.info.width;</span><br><span class="line">        height_ = map_.info.height;</span><br><span class="line">        resolution_ = map_.info.resolution;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收到地图后，开始规划路径</span></span><br><span class="line">        <span class="built_in">planPath</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 索引转换函数：将(x,y)转换为一维数组索引</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">toIndex</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y * width_ + x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查点(x,y)是否在地图范围内且无障碍物</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= width_ || y &lt; <span class="number">0</span> || y &gt;= height_)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> map_.data[<span class="built_in">toIndex</span>(x, y)] == <span class="number">0</span>; <span class="comment">// 0表示无障碍物</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算两点间的欧几里得距离</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">distance</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x1 - x2, <span class="number">2</span>) + <span class="built_in">pow</span>(y1 - y2, <span class="number">2</span>)) * resolution_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将世界坐标转换为地图格点坐标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">worldToMap</span><span class="params">(<span class="type">double</span> wx, <span class="type">double</span> wy, <span class="type">int</span>&amp; mx, <span class="type">int</span>&amp; my)</span> </span>&#123;</span><br><span class="line">        mx = (wx - map_.info.origin.position.x) / resolution_;</span><br><span class="line">        my = (wy - map_.info.origin.position.y) / resolution_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将地图格点坐标转换为世界坐标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mapToWorld</span><span class="params">(<span class="type">int</span> mx, <span class="type">int</span> my, <span class="type">double</span>&amp; wx, <span class="type">double</span>&amp; wy)</span> </span>&#123;</span><br><span class="line">        wx = mx * resolution_ + map_.info.origin.position.x;</span><br><span class="line">        wy = my * resolution_ + map_.info.origin.position.y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Dijkstra路径规划算法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">planPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将起点和终点从世界坐标转换为地图格点坐标</span></span><br><span class="line">        <span class="type">int</span> start_x, start_y, goal_x, goal_y;</span><br><span class="line">        <span class="built_in">worldToMap</span>(start_.pose.position.x, start_.pose.position.y, start_x, start_y);</span><br><span class="line">        <span class="built_in">worldToMap</span>(goal_.pose.position.x, goal_.pose.position.y, goal_x, goal_y);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查起点和终点是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isValid</span>(start_x, start_y) || !<span class="built_in">isValid</span>(goal_x, goal_y)) &#123;</span><br><span class="line">            <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;起点或终点无效！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化距离和前驱数组</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">d</span><span class="params">(width_ * height_, std::numeric_limits&lt;<span class="type">double</span>&gt;::infinity())</span></span>;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">prev</span><span class="params">(width_ * height_, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 优先队列，按距离升序排列</span></span><br><span class="line">        <span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; Node;  <span class="comment">// &lt;距离, 索引&gt;</span></span><br><span class="line">        std::priority_queue&lt;Node, std::vector&lt;Node&gt;, std::greater&lt;Node&gt;&gt; Q;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 起点距离设为0</span></span><br><span class="line">        <span class="type">int</span> start_idx = <span class="built_in">toIndex</span>(start_x, start_y);</span><br><span class="line">        d[start_idx] = <span class="number">0</span>;</span><br><span class="line">        Q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, start_idx));</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Dijkstra主循环</span></span><br><span class="line">        <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>() &amp;&amp; !found) &#123;</span><br><span class="line">            Node node = Q.<span class="built_in">top</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> u_idx = node.second;</span><br><span class="line">            <span class="type">int</span> u_x = u_idx % width_;</span><br><span class="line">            <span class="type">int</span> u_y = u_idx / width_;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果到达终点，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (u_x == goal_x &amp;&amp; u_y == goal_y) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前节点的距离已经更新过，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (node.first &gt; d[u_idx])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历8个相邻方向</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> v_x = u_x + dx[i];</span><br><span class="line">                <span class="type">int</span> v_y = u_y + dy[i];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isValid</span>(v_x, v_y))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="type">int</span> v_idx = <span class="built_in">toIndex</span>(v_x, v_y);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算从u到v的距离</span></span><br><span class="line">                <span class="type">double</span> weight = (i % <span class="number">2</span> == <span class="number">0</span>) ? resolution_ : <span class="built_in">sqrt</span>(<span class="number">2</span>) * resolution_;</span><br><span class="line">                <span class="type">double</span> alt = d[u_idx] + weight;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 松弛操作</span></span><br><span class="line">                <span class="keyword">if</span> (alt &lt; d[v_idx]) &#123;</span><br><span class="line">                    d[v_idx] = alt;</span><br><span class="line">                    prev[v_idx] = u_idx;</span><br><span class="line">                    Q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(alt, v_idx));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果找到路径，构建并发布</span></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;找到路径！&quot;</span>);</span><br><span class="line">            <span class="built_in">buildAndPublishPath</span>(prev, start_idx, <span class="built_in">toIndex</span>(goal_x, goal_y));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;未找到路径！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建并发布路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildAndPublishPath</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; prev, <span class="type">int</span> start_idx, <span class="type">int</span> goal_idx)</span> </span>&#123;</span><br><span class="line">        nav_msgs::Path path;</span><br><span class="line">        path.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        path.header.frame_id = map_.header.frame_id;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从终点回溯到起点，构建路径</span></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; path_indices;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> idx = goal_idx; idx != <span class="number">-1</span>; idx = prev[idx]) &#123;</span><br><span class="line">            path_indices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">            <span class="keyword">if</span> (idx == start_idx)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反转路径，从起点到终点</span></span><br><span class="line">        std::<span class="built_in">reverse</span>(path_indices.<span class="built_in">begin</span>(), path_indices.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构建路径消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> idx : path_indices) &#123;</span><br><span class="line">            <span class="type">int</span> x = idx % width_;</span><br><span class="line">            <span class="type">int</span> y = idx / width_;</span><br><span class="line">            </span><br><span class="line">            <span class="type">double</span> wx, wy;</span><br><span class="line">            <span class="built_in">mapToWorld</span>(x, y, wx, wy);</span><br><span class="line">            </span><br><span class="line">            geometry_msgs::PoseStamped pose;</span><br><span class="line">            pose.header = path.header;</span><br><span class="line">            pose.pose.position.x = wx;</span><br><span class="line">            pose.pose.position.y = wy;</span><br><span class="line">            pose.pose.position.z = <span class="number">0.0</span>;</span><br><span class="line">            pose.pose.orientation.w = <span class="number">1.0</span>;</span><br><span class="line">            </span><br><span class="line">            path.poses.<span class="built_in">push_back</span>(pose);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发布路径</span></span><br><span class="line">        path_pub_.<span class="built_in">publish</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;dijkstra_planner&quot;</span>);</span><br><span class="line">    DijkstraPlanner planner;</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Dijkstra的扩展与变体"><a href="#5-Dijkstra的扩展与变体" class="headerlink" title="5. Dijkstra的扩展与变体"></a>5. Dijkstra的扩展与变体</h2><p>Dijkstra算法虽然能够有效地求解最短路径问题，但在实际的ROS应用中，我们通常会看到一些变体和扩展，以适应不同的路径规划需求：</p>
<h3 id="1-A-算法：启发式Dijkstra"><a href="#1-A-算法：启发式Dijkstra" class="headerlink" title="1. A*算法：启发式Dijkstra"></a>1. A*算法：启发式Dijkstra</h3><p>A<em>算法是Dijkstra算法的一个扩展，它引入了启发式函数h(n)来估计从当前节点到目标节点的距离。A</em>算法的优先级函数为f(n) &#x3D; g(n) + h(n)，其中g(n)是从起点到节点n的实际代价（与Dijkstra相同），h(n)是从节点n到目标的估计代价。</p>
<p>在ROS中，A*算法是最常用的路径规划算法之一，尤其是在<code>nav_core</code>包和<code>global_planner</code>包中。</p>
<h3 id="2-D-算法：动态Dijkstra"><a href="#2-D-算法：动态Dijkstra" class="headerlink" title="2. D*算法：动态Dijkstra"></a>2. D*算法：动态Dijkstra</h3><p>D<em>（Dynamic A</em>）是一种增量搜索算法，适用于动态环境中的路径规划。当环境中的障碍物发生变化时，D*不需要从头开始重新规划，而是可以快速修复之前的路径。</p>
<p>在ROS导航堆栈中，<code>global_planner</code>和<code>navfn</code>包提供了类似功能的实现。</p>
<h3 id="3-带惩罚项的Dijkstra"><a href="#3-带惩罚项的Dijkstra" class="headerlink" title="3. 带惩罚项的Dijkstra"></a>3. 带惩罚项的Dijkstra</h3><p>为了让机器人避开障碍物的边缘或特定区域，可以在距离计算中引入惩罚项。例如，靠近障碍物的格点会被赋予更高的代价，从而使规划出的路径尽量远离障碍物。</p>
<p>以上这些变体和扩展使得Dijkstra算法在ROS的路径规划中能够适应各种复杂的应用场景，提供安全、高效的导航能力。</p>
<h2 id="长期-A"><a href="#长期-A" class="headerlink" title="长期 -A*"></a>长期 -A*</h2><h1 id="A-算法在ROS中的实现"><a href="#A-算法在ROS中的实现" class="headerlink" title="A*算法在ROS中的实现"></a>A*算法在ROS中的实现</h1><h2 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>A<em>算法是一种启发式搜索算法，是Dijkstra算法的扩展，广泛应用于机器人路径规划。在ROS（机器人操作系统）中，A</em>算法作为全局路径规划器的核心组件，帮助机器人在复杂环境中找到从起点到目标点的最优路径。</p>
<h3 id="核心数学变量定义-1"><a href="#核心数学变量定义-1" class="headerlink" title="核心数学变量定义"></a>核心数学变量定义</h3><ul>
<li><strong>G(V, E)</strong>: 表示一个图，V为顶点集合，E为边集合</li>
<li><strong>s</strong>: 源顶点，路径的起始点</li>
<li><strong>t</strong>: 目标顶点，路径的终点</li>
<li><strong>g(n)</strong>: 从起点s到当前节点n的实际代价</li>
<li><strong>h(n)</strong>: 从当前节点n到目标t的估计代价（启发函数）</li>
<li><strong>f(n)</strong>: 总评估函数，f(n) &#x3D; g(n) + h(n)</li>
<li><strong>OPEN</strong>: 待探索的节点集合，按f值排序的优先队列</li>
<li><strong>CLOSED</strong>: 已探索过的节点集合</li>
<li><strong>parent[v]</strong>: 记录节点v的父节点，用于回溯构建最优路径</li>
<li><strong>w(u,v)</strong>: 边(u,v)的权重，表示从节点u到节点v的移动代价</li>
</ul>
<h2 id="2-基本思路与核心公式"><a href="#2-基本思路与核心公式" class="headerlink" title="2. 基本思路与核心公式"></a>2. 基本思路与核心公式</h2><h3 id="智能探路者：A-算法的形象比喻"><a href="#智能探路者：A-算法的形象比喻" class="headerlink" title="智能探路者：A*算法的形象比喻"></a>智能探路者：A*算法的形象比喻</h3><p>想象你是一位智能探险家，站在迷宫入口（起点s）。你有两种特殊能力：一是精确记录你已经走过的路程（g(n)），二是拥有”千里眼”能大致估计前方到目的地的距离（h(n)）。与普通探险家（Dijkstra）不同，你不会盲目探索所有方向，而是优先选择”已走距离+预估剩余距离”最短的路径。</p>
<ol>
<li><p><strong>起航准备</strong>：你站在入口处，手持地图和指南针。你在笔记本上记录：起点到自己的距离为0（g(s)&#x3D;0），预估到终点的距离为h(s)，总评估为f(s)&#x3D;g(s)+h(s)。你把自己的位置放入待探索清单OPEN中。</p>
</li>
<li><p><strong>智慧选择</strong>：每次行动时，你从OPEN中选择f值最小的位置n（最有希望的路径）。如果n就是目的地，那么任务完成！否则，你把n从OPEN移到CLOSED中，表示这个位置已经探索过。</p>
</li>
<li><p><strong>探索与更新</strong>：从当前位置n，你观察所有可直接到达的相邻位置m。对于每个位置m：</p>
<ul>
<li>如果m已在CLOSED中，说明已探索过更好的路径，忽略它。</li>
<li>如果m不在OPEN中，计算g(m)&#x3D;g(n)+w(n,m)，估计h(m)，计算f(m)&#x3D;g(m)+h(m)，将m加入OPEN，并记录其父节点为n。</li>
<li>如果m已在OPEN中，检查经由当前路径到达m是否更优（g(n)+w(n,m) &lt; g(m)）。如果是，更新g(m)和f(m)，并修改m的父节点为n。</li>
</ul>
</li>
<li><p><strong>前进或回溯</strong>：重复步骤2和3，直到找到目标或确定无路可走（OPEN为空）。</p>
</li>
</ol>
<h3 id="核心数学公式-1"><a href="#核心数学公式-1" class="headerlink" title="核心数学公式"></a>核心数学公式</h3><ol>
<li><p><strong>评估函数</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = g(n) + h(n)</span><br></pre></td></tr></table></figure>
<p>其中，f(n)是节点n的总评估值，g(n)是从起点到n的实际代价，h(n)是从n到目标的估计代价。</p>
</li>
<li><p><strong>启发函数</strong>（常用的几种）:</p>
<ul>
<li>欧几里得距离: <code>h(n) = √[(nx-tx)² + (ny-ty)²]</code></li>
<li>曼哈顿距离: <code>h(n) = |nx-tx| + |ny-ty|</code></li>
<li>对角线距离: <code>h(n) = max(|nx-tx|, |ny-ty|) + (√2-1)·min(|nx-tx|, |ny-ty|)</code></li>
</ul>
</li>
<li><p><strong>最优性条件</strong>:<br>当启发函数h(n)不高估实际代价（称为可接纳的，admissible）时，A*算法保证找到最优解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h(n) ≤ h*(n)  对所有n</span><br></pre></td></tr></table></figure>
<p>其中h*(n)是从n到目标的真实最短路径代价。</p>
</li>
<li><p><strong>一致性条件</strong>（也称为单调性）:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h(n) ≤ w(n,m) + h(m)  对所有相邻节点对(n,m)</span><br></pre></td></tr></table></figure>
<p>这意味着启发函数的估计值不会在移动时增加太多。当h满足一致性时，A*算法可以避免重复探索已处理节点。</p>
</li>
</ol>
<h2 id="3-数学推导-1"><a href="#3-数学推导-1" class="headerlink" title="3. 数学推导"></a>3. 数学推导</h2><p>A<em>算法的核心思想是结合Dijkstra算法的精确性与最佳优先搜索的效率。下面我们对A</em>算法的正确性和最优性进行严密推导。</p>
<h3 id="定理1：完备性"><a href="#定理1：完备性" class="headerlink" title="定理1：完备性"></a>定理1：完备性</h3><p>如果问题有解，且图中所有边的代价均为正，那么A*算法一定能找到一条从起点到目标的路径。</p>
<p><strong>证明</strong>：</p>
<ol>
<li>假设存在一条从起点s到目标t的路径，且所有边的代价均为正。</li>
<li>由于每次展开一个节点后，其所有邻居都会被加入OPEN集合。</li>
<li>每次迭代都会从OPEN中选择并展开一个节点。</li>
<li>由于边的代价均为正，g(n)单调递增，不会出现无限循环。</li>
<li>在有限步骤内，要么找到目标，要么探索完所有可达节点（此时OPEN为空）。</li>
<li>如果问题有解，目标节点t必然会被添加到OPEN中，并最终被选中展开。</li>
</ol>
<h3 id="定理2：最优性"><a href="#定理2：最优性" class="headerlink" title="定理2：最优性"></a>定理2：最优性</h3><p>如果启发函数h(n)是可接纳的（不高估），那么A*算法找到的路径是最优的。</p>
<p><strong>证明</strong>：</p>
<ol>
<li>令h*(n)表示从节点n到目标t的实际最短路径代价。</li>
<li>令g*(n)表示从起点s到节点n的实际最短路径代价。</li>
<li>假设h(n)≤h*(n)对所有n成立（可接纳性）。</li>
<li>考虑最优路径上的任意节点n，有f*(n)&#x3D;g*(n)+h*(n)。</li>
<li>在A*算法中，f(n)&#x3D;g(n)+h(n)。</li>
<li>对于最优路径上的节点n，如果g(n)&#x3D;g*(n)，则f(n)&#x3D;g*(n)+h(n)≤g*(n)+h*(n)&#x3D;f*(n)。</li>
<li>这意味着最优路径上的节点n的f值不会大于真实最优路径的代价f*(t)。</li>
<li>因此，A<em>算法会在探索任何f值大于f</em>(t)的节点之前先探索完最优路径上的所有节点。</li>
<li>当目标节点t被选中展开时，由于g(t)&#x3D;g*(t)（已找到最短路径），算法终止。</li>
</ol>
<h3 id="定理3：效率（对于一致的启发函数）"><a href="#定理3：效率（对于一致的启发函数）" class="headerlink" title="定理3：效率（对于一致的启发函数）"></a>定理3：效率（对于一致的启发函数）</h3><p>如果启发函数h(n)满足一致性条件：h(n)≤w(n,m)+h(m)，则：</p>
<ol>
<li>当节点n从OPEN移至CLOSED时，g(n)&#x3D;g*(n)，即已找到从s到n的最短路径。</li>
<li>每个节点最多只会被展开一次。</li>
</ol>
<p><strong>证明</strong>：</p>
<ol>
<li>归纳假设：对于每个从OPEN移至CLOSED的节点n，有g(n)&#x3D;g*(n)。</li>
<li>基本情况：起点s，显然g(s)&#x3D;g*(s)&#x3D;0。</li>
<li>归纳步骤：假设对于已在CLOSED中的所有节点，归纳假设成立。</li>
<li>考虑即将从OPEN移至CLOSED的节点n。设p是n的父节点，则g(n)&#x3D;g(p)+w(p,n)。</li>
<li>由归纳假设，g(p)&#x3D;g*(p)。</li>
<li>反证法：假设g(n)≠g*(n)，则必有g(n)&gt;g*(n)。</li>
<li>考虑从s到n的实际最短路径，设q是该路径上n的前一个节点。</li>
<li>由归纳假设，q在CLOSED中，且g(q)&#x3D;g*(q)。</li>
<li>当q被展开时，n被添加到OPEN中或其g值被更新为g(q)+w(q,n)&#x3D;g*(n)。</li>
<li>这与假设g(n)&gt;g*(n)矛盾。</li>
<li>因此，g(n)&#x3D;g*(n)，归纳假设对新的CLOSED∪{n}成立。</li>
<li>一旦节点n进入CLOSED，其g值不再改变，因此每个节点最多只会被展开一次。</li>
</ol>
<h2 id="4-ROS源码实现-1"><a href="#4-ROS源码实现-1" class="headerlink" title="4. ROS源码实现"></a>4. ROS源码实现</h2><p>以下是在ROS中实现A*算法的核心代码，适用于机器人导航中的全局路径规划：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nav_msgs/OccupancyGrid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nav_msgs/Path.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/PoseStamped.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AStar</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 地图和路径相关</span></span><br><span class="line">    nav_msgs::OccupancyGrid map_;</span><br><span class="line">    <span class="type">int</span> width_, height_;</span><br><span class="line">    <span class="type">double</span> resolution_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ROS接口</span></span><br><span class="line">    ros::NodeHandle nh_;</span><br><span class="line">    ros::Subscriber map_sub_;</span><br><span class="line">    ros::Publisher path_pub_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启发函数类型</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">HeuristicType</span> &#123;</span><br><span class="line">        MANHATTAN,</span><br><span class="line">        EUCLIDEAN,</span><br><span class="line">        DIAGONAL</span><br><span class="line">    &#125; heuristic_type_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方向数组（8方向）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> cost[<span class="number">8</span>] = &#123;<span class="number">1.0</span>, <span class="number">1.414</span>, <span class="number">1.0</span>, <span class="number">1.414</span>, <span class="number">1.0</span>, <span class="number">1.414</span>, <span class="number">1.0</span>, <span class="number">1.414</span>&#125;; <span class="comment">// 直线和对角线代价</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点结构</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, y;  <span class="comment">// 坐标</span></span><br><span class="line">        <span class="type">double</span> g;  <span class="comment">// 从起点到当前的代价</span></span><br><span class="line">        <span class="type">double</span> h;  <span class="comment">// 启发函数值</span></span><br><span class="line">        <span class="type">double</span> f;  <span class="comment">// f = g + h</span></span><br><span class="line">        <span class="type">int</span> parent_x, parent_y;  <span class="comment">// 父节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较运算符重载，用于优先队列</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Node&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f &gt; other.f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AStar</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化ROS接口</span></span><br><span class="line">        map_sub_ = nh_.<span class="built_in">subscribe</span>(<span class="string">&quot;/map&quot;</span>, <span class="number">1</span>, &amp;AStar::mapCallback, <span class="keyword">this</span>);</span><br><span class="line">        path_pub_ = nh_.<span class="built_in">advertise</span>&lt;nav_msgs::Path&gt;(<span class="string">&quot;/path&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 配置参数</span></span><br><span class="line">        std::string heuristic;</span><br><span class="line">        nh_.<span class="built_in">param</span>&lt;std::string&gt;(<span class="string">&quot;heuristic&quot;</span>, heuristic, <span class="string">&quot;euclidean&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (heuristic == <span class="string">&quot;manhattan&quot;</span>)</span><br><span class="line">            heuristic_type_ = MANHATTAN;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (heuristic == <span class="string">&quot;diagonal&quot;</span>)</span><br><span class="line">            heuristic_type_ = DIAGONAL;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            heuristic_type_ = EUCLIDEAN;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地图回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mapCallback</span><span class="params">(<span class="type">const</span> nav_msgs::OccupancyGrid::ConstPtr&amp; map)</span> </span>&#123;</span><br><span class="line">        map_ = *map;</span><br><span class="line">        width_ = map_.info.width;</span><br><span class="line">        height_ = map_.info.height;</span><br><span class="line">        resolution_ = map_.info.resolution;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算启发函数值</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateHeuristic</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> dx = <span class="built_in">abs</span>(x1 - x2);</span><br><span class="line">        <span class="type">double</span> dy = <span class="built_in">abs</span>(y1 - y2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> (heuristic_type_) &#123;</span><br><span class="line">            <span class="keyword">case</span> MANHATTAN:</span><br><span class="line">                <span class="keyword">return</span> (dx + dy) * resolution_;</span><br><span class="line">            <span class="keyword">case</span> DIAGONAL:</span><br><span class="line">                <span class="keyword">return</span> (dx + dy + (<span class="built_in">sqrt</span>(<span class="number">2</span>) - <span class="number">2</span>) * std::<span class="built_in">min</span>(dx, dy)) * resolution_;</span><br><span class="line">            <span class="keyword">case</span> EUCLIDEAN:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx + dy*dy) * resolution_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要的A*算法实现</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findPath</span><span class="params">(<span class="type">double</span> start_x, <span class="type">double</span> start_y, <span class="type">double</span> goal_x, <span class="type">double</span> goal_y, nav_msgs::Path&amp; path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将世界坐标转换为地图坐标</span></span><br><span class="line">        <span class="type">int</span> start_mx = (start_x - map_.info.origin.position.x) / resolution_;</span><br><span class="line">        <span class="type">int</span> start_my = (start_y - map_.info.origin.position.y) / resolution_;</span><br><span class="line">        <span class="type">int</span> goal_mx = (goal_x - map_.info.origin.position.x) / resolution_;</span><br><span class="line">        <span class="type">int</span> goal_my = (goal_y - map_.info.origin.position.y) / resolution_;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查起点和终点是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isValid</span>(start_mx, start_my) || !<span class="built_in">isValid</span>(goal_mx, goal_my)) &#123;</span><br><span class="line">            <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;起点或终点无效！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化开放列表（优先队列）和关闭列表</span></span><br><span class="line">        std::priority_queue&lt;Node, std::vector&lt;Node&gt;, std::greater&lt;Node&gt;&gt; openList;</span><br><span class="line">        std::vector&lt;std::vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">closedList</span>(width_, std::<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(height_, <span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用于存储g值和父节点</span></span><br><span class="line">        std::vector&lt;std::vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">g_score</span>(width_, std::<span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(height_, std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>()));</span><br><span class="line">        std::vector&lt;std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">parent</span>(width_, std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;(height_, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加起点到开放列表</span></span><br><span class="line">        g_score[start_mx][start_my] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> h = <span class="built_in">calculateHeuristic</span>(start_mx, start_my, goal_mx, goal_my);</span><br><span class="line">        </span><br><span class="line">        Node startNode = &#123;start_mx, start_my, <span class="number">0</span>, h, <span class="number">0</span> + h, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        openList.<span class="built_in">push</span>(startNode);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!openList.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 获取f值最小的节点</span></span><br><span class="line">            Node current = openList.<span class="built_in">top</span>();</span><br><span class="line">            openList.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> x = current.x;</span><br><span class="line">            <span class="type">int</span> y = current.y;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果已经在关闭列表中，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (closedList[x][y])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加到关闭列表</span></span><br><span class="line">            closedList[x][y] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果到达目标，构建路径并返回</span></span><br><span class="line">            <span class="keyword">if</span> (x == goal_mx &amp;&amp; y == goal_my) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">reconstructPath</span>(parent, start_mx, start_my, goal_mx, goal_my, path);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查所有相邻节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> newX = x + dx[i];</span><br><span class="line">                <span class="type">int</span> newY = y + dy[i];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 检查是否有效且不在关闭列表中</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isValid</span>(newX, newY) || closedList[newX][newY])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算新的g值</span></span><br><span class="line">                <span class="type">double</span> tentative_g = g_score[x][y] + cost[i] * resolution_;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果新路径更好</span></span><br><span class="line">                <span class="keyword">if</span> (tentative_g &lt; g_score[newX][newY]) &#123;</span><br><span class="line">                    <span class="comment">// 更新g值和父节点</span></span><br><span class="line">                    g_score[newX][newY] = tentative_g;</span><br><span class="line">                    parent[newX][newY] = &#123;x, y&#125;;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 计算h值和f值</span></span><br><span class="line">                    <span class="type">double</span> h = <span class="built_in">calculateHeuristic</span>(newX, newY, goal_mx, goal_my);</span><br><span class="line">                    <span class="type">double</span> f = tentative_g + h;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 添加到开放列表</span></span><br><span class="line">                    Node newNode = &#123;newX, newY, tentative_g, h, f, x, y&#125;;</span><br><span class="line">                    openList.<span class="built_in">push</span>(newNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果开放列表为空且未找到路径，返回失败</span></span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;未找到路径！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查点(x,y)是否在地图范围内且无障碍物</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= width_ || y &lt; <span class="number">0</span> || y &gt;= height_)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> map_.data[y * width_ + x] &lt; <span class="number">50</span>; <span class="comment">// 阈值50，小于50认为是自由空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重建路径</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">reconstructPath</span><span class="params">(<span class="type">const</span> std::vector&lt;std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt;&amp; parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">int</span> start_x, <span class="type">int</span> start_y, <span class="type">int</span> goal_x, <span class="type">int</span> goal_y,</span></span></span><br><span class="line"><span class="params"><span class="function">                         nav_msgs::Path&amp; path)</span> </span>&#123;</span><br><span class="line">        path.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        path.header.frame_id = map_.header.frame_id;</span><br><span class="line">        path.poses.<span class="built_in">clear</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> x = goal_x;</span><br><span class="line">        <span class="type">int</span> y = goal_y;</span><br><span class="line">        </span><br><span class="line">        std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; path_points;</span><br><span class="line">        path_points.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从目标回溯到起点</span></span><br><span class="line">        <span class="keyword">while</span> (!(x == start_x &amp;&amp; y == start_y)) &#123;</span><br><span class="line">            std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p = parent[x][y];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (p.first == <span class="number">-1</span> &amp;&amp; p.second == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;路径回溯失败！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            x = p.first;</span><br><span class="line">            y = p.second;</span><br><span class="line">            path_points.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反转路径，从起点到目标</span></span><br><span class="line">        std::<span class="built_in">reverse</span>(path_points.<span class="built_in">begin</span>(), path_points.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换为ROS路径消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; point : path_points) &#123;</span><br><span class="line">            geometry_msgs::PoseStamped pose;</span><br><span class="line">            pose.header = path.header;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将地图坐标转换回世界坐标</span></span><br><span class="line">            pose.pose.position.x = point.first * resolution_ + map_.info.origin.position.x;</span><br><span class="line">            pose.pose.position.y = point.second * resolution_ + map_.info.origin.position.y;</span><br><span class="line">            pose.pose.position.z = <span class="number">0.0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 设置方向（简化为朝向x轴正方向）</span></span><br><span class="line">            pose.pose.orientation.w = <span class="number">1.0</span>;</span><br><span class="line">            </span><br><span class="line">            path.poses.<span class="built_in">push_back</span>(pose);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发布路径</span></span><br><span class="line">        path_pub_.<span class="built_in">publish</span>(path);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;astar_planner&quot;</span>);</span><br><span class="line">    AStar astar;</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-A-算法的变体与优化"><a href="#5-A-算法的变体与优化" class="headerlink" title="5. A*算法的变体与优化"></a>5. A*算法的变体与优化</h2><p>A*算法在实际应用中有多种变体和优化方法，用于解决不同情境下的路径规划问题：</p>
<h3 id="1-加权A-算法"><a href="#1-加权A-算法" class="headerlink" title="1. 加权A*算法"></a>1. 加权A*算法</h3><p>加权A*通过修改评估函数：<code>f(n) = g(n) + w·h(n)</code>，其中w &gt; 1是一个权重因子。增加权重会使算法更倾向于启发信息，加快搜索速度，但可能会牺牲路径的最优性。在ROS中，这种方法常用于需要快速响应的实时路径规划。</p>
<h3 id="2-D-Lite算法"><a href="#2-D-Lite算法" class="headerlink" title="2. D* Lite算法"></a>2. D* Lite算法</h3><p>D* Lite是A<em>的动态版本，适合处理环境变化的情况。当机器人探测到新障碍物时，D</em> Lite可以高效地重新规划路径，而不需要完全重新计算。ROS导航栈中的全局规划器有时会采用类似方法。</p>
<h3 id="3-Anytime-Repairing-A-ARA"><a href="#3-Anytime-Repairing-A-ARA" class="headerlink" title="3. Anytime Repairing A* (ARA*)"></a>3. Anytime Repairing A* (ARA*)</h3><p>ARA*是一种随时可用的算法，它首先快速找到一条次优路径，然后在有更多时间的情况下逐步改进。这对于有时间限制的机器人决策非常有用。</p>
<h3 id="4-跳点搜索-Jump-Point-Search-JPS"><a href="#4-跳点搜索-Jump-Point-Search-JPS" class="headerlink" title="4. 跳点搜索 (Jump Point Search, JPS)"></a>4. 跳点搜索 (Jump Point Search, JPS)</h3><p>JPS是A*在网格地图上的优化版本，通过识别”跳点”来减少冗余节点的检查，显著提高搜索速度。在均匀代价网格中特别有效。</p>
<p>在ROS的实际应用中，选择哪种A*变体通常取决于具体任务的需求：是否需要最优解，计算资源限制，环境动态性等因素。ROS的move_base包允许开发者方便地替换和配置不同的全局规划器，以适应各种场景需求。</p>
<p>我将分别讲解DWA和TEB算法，每个算法都按照四个章节进行详细说明。</p>
<h1 id="DWA-Dynamic-Window-Approach-算法"><a href="#DWA-Dynamic-Window-Approach-算法" class="headerlink" title="DWA (Dynamic Window Approach) 算法"></a>DWA (Dynamic Window Approach) 算法</h1><h2 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>DWA (Dynamic Window Approach) 是一种经典的局部路径规划算法，特别适用于机器人实时避障和轨迹生成。在ROS导航栈中，DWA作为默认的局部规划器被广泛使用。</p>
<h3 id="核心数学变量定义-2"><a href="#核心数学变量定义-2" class="headerlink" title="核心数学变量定义"></a>核心数学变量定义</h3><ul>
<li><strong>v</strong>: 线速度，机器人前进的速度</li>
<li><strong>ω</strong>: 角速度，机器人旋转的速度</li>
<li><strong>vₘₐₓ</strong>: 机器人最大线速度限制</li>
<li><strong>ωₘₐₓ</strong>: 机器人最大角速度限制</li>
<li><strong>aᵥ</strong>: 线加速度限制</li>
<li><strong>aω</strong>: 角加速度限制</li>
<li><strong>V_s</strong>: 安全速度空间，考虑障碍物的速度约束</li>
<li><strong>V_d</strong>: 动态窗口，考虑机器人动力学约束的速度空间</li>
<li><strong>V_r</strong>: 可达速度空间，考虑采样时间内的可达速度</li>
<li><strong>G(v, ω)</strong>: 目标函数，用于评估速度采样点的优劣</li>
<li><strong>α, β, γ</strong>: 目标函数中各个子目标的权重系数</li>
</ul>
<h2 id="2-基本思路与核心公式-1"><a href="#2-基本思路与核心公式-1" class="headerlink" title="2. 基本思路与核心公式"></a>2. 基本思路与核心公式</h2><h3 id="赛车驾驶员：DWA算法的形象比喻"><a href="#赛车驾驶员：DWA算法的形象比喻" class="headerlink" title="赛车驾驶员：DWA算法的形象比喻"></a>赛车驾驶员：DWA算法的形象比喻</h3><p>想象你是一位自动驾驶赛车的AI驾驶员。在高速行驶的同时，你需要不断做出决策：应该加速还是减速？应该向左转还是向右转？每次决策都基于三个关键考虑：</p>
<ol>
<li><strong>安全性</strong> - 我能否在这个速度下安全停车而不撞到障碍物？</li>
<li><strong>目标导向性</strong> - 这个速度选择会让我更接近终点线吗？</li>
<li><strong>速度偏好</strong> - 在安全的前提下，我能开得越快越好，并且行驶轨迹越平滑越好。</li>
</ol>
<p>作为AI驾驶员，你的”思考过程”如下：</p>
<ol>
<li><p><strong>观察赛道</strong> (感知周围环境):<br>通过传感器获取周围障碍物信息。</p>
</li>
<li><p><strong>确定可行速度窗口</strong> (动态窗口计算):</p>
<ul>
<li>考虑赛车的动力学约束 - 你不能瞬间从0加速到200km&#x2F;h</li>
<li>考虑赛车的安全性约束 - 你需要保持足够的制动距离</li>
<li>最终得到一个”动态窗口”，即在短时间内可以安全达到的速度范围</li>
</ul>
</li>
<li><p><strong>模拟不同驾驶方案</strong> (轨迹模拟与评估):</p>
<ul>
<li>在动态窗口内采样多个速度组合(v, ω)</li>
<li>对每个速度组合，模拟赛车在短时间内的行驶轨迹</li>
<li>评估每条轨迹的优劣，综合考虑：<ul>
<li>轨迹与障碍物的距离 (安全性)</li>
<li>轨迹朝向目标的程度 (目标导向性)</li>
<li>轨迹的速度大小 (速度偏好)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>选择最佳方案并执行</strong> (最优控制量选择):<br>选择评分最高的速度组合，控制赛车执行，然后循环重复上述决策过程。</p>
</li>
</ol>
<h3 id="核心数学公式-2"><a href="#核心数学公式-2" class="headerlink" title="核心数学公式"></a>核心数学公式</h3><ol>
<li><p><strong>动态窗口定义</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V_d = [v_c - a_v·Δt, v_c + a_v·Δt] × [ω_c - a_ω·Δt, ω_c + a_ω·Δt]</span><br></pre></td></tr></table></figure>
<p>其中，(v_c, ω_c)是当前速度，a_v和a_ω是加速度限制，Δt是采样时间。</p>
</li>
<li><p><strong>目标函数</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G(v, ω) = α·heading(v, ω) + β·dist(v, ω) + γ·velocity(v, ω)</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>heading(v, ω): 评估轨迹朝向目标的程度</li>
<li>dist(v, ω): 评估轨迹与最近障碍物的距离</li>
<li>velocity(v, ω): 评估轨迹的前进速度</li>
<li>α, β, γ: 权重系数，用于平衡各子目标的重要性</li>
</ul>
</li>
<li><p><strong>机器人运动模型</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x(t) = x_0 + ∫[0,t] v·cos(θ(τ))dτ</span><br><span class="line">y(t) = y_0 + ∫[0,t] v·sin(θ(τ))dτ</span><br><span class="line">θ(t) = θ_0 + ∫[0,t] ω·dτ</span><br></pre></td></tr></table></figure>
<p>其中，(x_0, y_0, θ_0)是初始状态，(v, ω)是控制输入。</p>
</li>
<li><p><strong>安全速度约束</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v ≤ √(2·d_ob·a_v)</span><br></pre></td></tr></table></figure>
<p>其中，d_ob是到障碍物的距离，a_v是减速度。</p>
</li>
</ol>
<h2 id="3-数学推导-2"><a href="#3-数学推导-2" class="headerlink" title="3. 数学推导"></a>3. 数学推导</h2><p>DWA算法的核心是通过对速度空间的采样和评估，找到最优的控制输入。下面我们对算法的关键部分进行严密推导。</p>
<h3 id="1-动态窗口的数学表示"><a href="#1-动态窗口的数学表示" class="headerlink" title="1. 动态窗口的数学表示"></a>1. 动态窗口的数学表示</h3><p>动态窗口是考虑机器人动力学约束后的可行速度空间，由三个速度集合的交集定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V_r = V_s ∩ V_a ∩ V_d</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><p><strong>V_s</strong>: 安全速度空间，保证机器人能在不碰撞障碍物的情况下停止</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V_s = &#123;(v, ω) | v ≤ √(2·d_ob(v, ω)·a_v), |ω| ≤ ωₘₐₓ&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>V_a</strong>: 可达速度空间，考虑机器人速度限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V_a = &#123;(v, ω) | v ∈ [0, vₘₐₓ], ω ∈ [-ωₘₐₓ, ωₘₐₓ]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>V_d</strong>: 动态窗口，考虑机器人在采样时间内的加速度约束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V_d = &#123;(v, ω) | v ∈ [v_c - a_v·Δt, v_c + a_v·Δt], </span><br><span class="line">               ω ∈ [ω_c - a_ω·Δt, ω_c + a_ω·Δt]&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-轨迹预测模型"><a href="#2-轨迹预测模型" class="headerlink" title="2. 轨迹预测模型"></a>2. 轨迹预测模型</h3><p>给定控制输入(v, ω)，机器人在时间t后的位置可以通过积分运动方程得到：</p>
<p>对于恒定控制输入(v, ω)，有：</p>
<ul>
<li><p>如果ω≠0（圆弧轨迹）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x(t) = x_c + R·[sin(θ_c + ω·t) - sin(θ_c)]</span><br><span class="line">y(t) = y_c + R·[cos(θ_c) - cos(θ_c + ω·t)]</span><br><span class="line">θ(t) = θ_c + ω·t</span><br></pre></td></tr></table></figure>
<p>其中R &#x3D; v&#x2F;ω是轨迹圆弧的半径。</p>
</li>
<li><p>如果ω&#x3D;0（直线轨迹）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x(t) = x_c + v·t·cos(θ_c)</span><br><span class="line">y(t) = y_c + v·t·sin(θ_c)</span><br><span class="line">θ(t) = θ_c</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-目标函数详细推导"><a href="#3-目标函数详细推导" class="headerlink" title="3. 目标函数详细推导"></a>3. 目标函数详细推导</h3><p>目标函数G(v, ω)评估速度组合(v, ω)的优劣，由三个归一化的子目标函数组成：</p>
<ol>
<li><p><strong>朝向目标评分 heading(v, ω)</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heading(v, ω) = 1 - |θ_goal - θ_pred(v, ω)| / π</span><br></pre></td></tr></table></figure>
<p>其中θ_goal是目标方向，θ_pred是预测轨迹终点的朝向。</p>
</li>
<li><p><strong>避障评分 dist(v, ω)</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dist(v, ω) = min(d_ob(v, ω), d_max) / d_max</span><br></pre></td></tr></table></figure>
<p>其中d_ob是预测轨迹到最近障碍物的距离，d_max是截断距离。</p>
</li>
<li><p><strong>速度评分 velocity(v, ω)</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">velocity(v, ω) = v / vₘₐₓ</span><br></pre></td></tr></table></figure></li>
</ol>
<p>将这三个评分加权组合得到最终目标函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G(v, ω) = α·heading(v, ω) + β·dist(v, ω) + γ·velocity(v, ω)</span><br></pre></td></tr></table></figure>

<p>最终，算法选择目标函数最大的速度组合作为控制输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(v*, ω*) = argmax_&#123;(v,ω)∈V_r&#125; G(v, ω)</span><br></pre></td></tr></table></figure>

<h2 id="4-ROS源码实现-2"><a href="#4-ROS源码实现-2" class="headerlink" title="4. ROS源码实现"></a>4. ROS源码实现</h2><p>以下是DWA算法在ROS中的核心实现，基于move_base包中的<code>dwa_local_planner</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nav_msgs/Odometry.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nav_msgs/Path.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;costmap_2d/costmap_2d_ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;base_local_planner/trajectory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DWAPlanner</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ROS接口</span></span><br><span class="line">    ros::NodeHandle nh_;</span><br><span class="line">    ros::Publisher vel_pub_;</span><br><span class="line">    ros::Subscriber odom_sub_;</span><br><span class="line">    ros::Subscriber goal_sub_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 规划参数</span></span><br><span class="line">    <span class="type">double</span> max_vel_x_, min_vel_x_, max_vel_theta_, max_accel_x_, max_accel_theta_;</span><br><span class="line">    <span class="type">double</span> sim_time_, sim_granularity_;</span><br><span class="line">    <span class="type">double</span> path_distance_bias_, goal_distance_bias_, occdist_scale_;</span><br><span class="line">    <span class="type">int</span> vx_samples_, vtheta_samples_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 机器人状态</span></span><br><span class="line">    <span class="type">double</span> current_vel_x_, current_vel_theta_;</span><br><span class="line">    geometry_msgs::PoseStamped current_pose_;</span><br><span class="line">    geometry_msgs::PoseStamped goal_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代价地图</span></span><br><span class="line">    costmap_2d::Costmap2DROS* costmap_ros_;</span><br><span class="line">    costmap_2d::Costmap2D* costmap_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DWAPlanner</span>() : <span class="built_in">nh_</span>(<span class="string">&quot;~&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化参数</span></span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;max_vel_x&quot;</span>, max_vel_x_, <span class="number">0.5</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;min_vel_x&quot;</span>, min_vel_x_, <span class="number">0.0</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;max_vel_theta&quot;</span>, max_vel_theta_, <span class="number">1.0</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;max_accel_x&quot;</span>, max_accel_x_, <span class="number">1.0</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;max_accel_theta&quot;</span>, max_accel_theta_, <span class="number">2.0</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;sim_time&quot;</span>, sim_time_, <span class="number">1.5</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;sim_granularity&quot;</span>, sim_granularity_, <span class="number">0.025</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;path_distance_bias&quot;</span>, path_distance_bias_, <span class="number">0.6</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;goal_distance_bias&quot;</span>, goal_distance_bias_, <span class="number">0.8</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;occdist_scale&quot;</span>, occdist_scale_, <span class="number">0.01</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;vx_samples&quot;</span>, vx_samples_, <span class="number">20</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;vtheta_samples&quot;</span>, vtheta_samples_, <span class="number">40</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化ROS接口</span></span><br><span class="line">        vel_pub_ = nh_.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/cmd_vel&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        odom_sub_ = nh_.<span class="built_in">subscribe</span>(<span class="string">&quot;/odom&quot;</span>, <span class="number">1</span>, &amp;DWAPlanner::odomCallback, <span class="keyword">this</span>);</span><br><span class="line">        goal_sub_ = nh_.<span class="built_in">subscribe</span>(<span class="string">&quot;/move_base_simple/goal&quot;</span>, <span class="number">1</span>, &amp;DWAPlanner::goalCallback, <span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化代价地图</span></span><br><span class="line">        costmap_ros_ = <span class="keyword">new</span> costmap_2d::<span class="built_in">Costmap2DROS</span>(<span class="string">&quot;local_costmap&quot;</span>, tf_);</span><br><span class="line">        costmap_ = costmap_ros_-&gt;<span class="built_in">getCostmap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">odomCallback</span><span class="params">(<span class="type">const</span> nav_msgs::Odometry::ConstPtr&amp; msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更新当前状态</span></span><br><span class="line">        current_vel_x_ = msg-&gt;twist.twist.linear.x;</span><br><span class="line">        current_vel_theta_ = msg-&gt;twist.twist.angular.z;</span><br><span class="line">        </span><br><span class="line">        current_pose_.pose = msg-&gt;pose.pose;</span><br><span class="line">        current_pose_.header = msg-&gt;header;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">goalCallback</span><span class="params">(<span class="type">const</span> geometry_msgs::PoseStamped::ConstPtr&amp; msg)</span> </span>&#123;</span><br><span class="line">        goal_ = *msg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">computeVelocityCommands</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否有目标</span></span><br><span class="line">        <span class="keyword">if</span> (goal_.header.stamp.<span class="built_in">isZero</span>()) &#123;</span><br><span class="line">            <span class="built_in">ROS_WARN</span>(<span class="string">&quot;No goal set&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算动态窗口</span></span><br><span class="line">        <span class="type">double</span> min_vel_x = std::<span class="built_in">max</span>(min_vel_x_, current_vel_x_ - max_accel_x_ * sim_time_);</span><br><span class="line">        <span class="type">double</span> max_vel_x = std::<span class="built_in">min</span>(max_vel_x_, current_vel_x_ + max_accel_x_ * sim_time_);</span><br><span class="line">        <span class="type">double</span> min_vel_theta = std::<span class="built_in">max</span>(-max_vel_theta_, current_vel_theta_ - max_accel_theta_ * sim_time_);</span><br><span class="line">        <span class="type">double</span> max_vel_theta = std::<span class="built_in">min</span>(max_vel_theta_, current_vel_theta_ + max_accel_theta_ * sim_time_);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在速度空间中采样轨迹</span></span><br><span class="line">        <span class="type">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">double</span> best_vel_x = <span class="number">0</span>, best_vel_theta = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span> vel_x_step = (max_vel_x - min_vel_x) / (vx_samples_ - <span class="number">1</span>);</span><br><span class="line">        <span class="type">double</span> vel_theta_step = (max_vel_theta - min_vel_theta) / (vtheta_samples_ - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vx_samples_; ++i) &#123;</span><br><span class="line">            <span class="type">double</span> vx = min_vel_x + i * vel_x_step;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vtheta_samples_; ++j) &#123;</span><br><span class="line">                <span class="type">double</span> vtheta = min_vel_theta + j * vel_theta_step;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 生成轨迹</span></span><br><span class="line">                base_local_planner::Trajectory traj;</span><br><span class="line">                <span class="built_in">generateTrajectory</span>(current_pose_, vx, vtheta, traj);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 评分轨迹</span></span><br><span class="line">                <span class="type">double</span> score = <span class="built_in">scoreTrajectory</span>(traj);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 更新最佳轨迹</span></span><br><span class="line">                <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">                    best_score = score;</span><br><span class="line">                    best_vel_x = vx;</span><br><span class="line">                    best_vel_theta = vtheta;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发布最佳速度命令</span></span><br><span class="line">        geometry_msgs::Twist cmd_vel;</span><br><span class="line">        cmd_vel.linear.x = best_vel_x;</span><br><span class="line">        cmd_vel.angular.z = best_vel_theta;</span><br><span class="line">        vel_pub_.<span class="built_in">publish</span>(cmd_vel);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">generateTrajectory</span><span class="params">(<span class="type">const</span> geometry_msgs::PoseStamped&amp; start, </span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">double</span> vx, <span class="type">double</span> vtheta, </span></span></span><br><span class="line"><span class="params"><span class="function">                           base_local_planner::Trajectory&amp; traj)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> x = start.pose.position.x;</span><br><span class="line">        <span class="type">double</span> y = start.pose.position.y;</span><br><span class="line">        <span class="type">double</span> theta = tf::<span class="built_in">getYaw</span>(start.pose.orientation);</span><br><span class="line">        </span><br><span class="line">        traj.<span class="built_in">resetPoints</span>();</span><br><span class="line">        traj.xv_ = vx;</span><br><span class="line">        traj.thetav_ = vtheta;</span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span> sim_time_step = sim_granularity_;</span><br><span class="line">        <span class="type">int</span> num_steps = <span class="built_in">ceil</span>(sim_time_ / sim_time_step);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_steps; ++i) &#123;</span><br><span class="line">            <span class="comment">// 更新位姿</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(vtheta) &lt; <span class="number">0.0001</span>) &#123; <span class="comment">// 直线运动</span></span><br><span class="line">                x += vx * sim_time_step * <span class="built_in">cos</span>(theta);</span><br><span class="line">                y += vx * sim_time_step * <span class="built_in">sin</span>(theta);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 圆弧运动</span></span><br><span class="line">                <span class="type">double</span> r = vx / vtheta;</span><br><span class="line">                x += r * (<span class="built_in">sin</span>(theta + vtheta * sim_time_step) - <span class="built_in">sin</span>(theta));</span><br><span class="line">                y += r * (<span class="built_in">cos</span>(theta) - <span class="built_in">cos</span>(theta + vtheta * sim_time_step));</span><br><span class="line">                theta += vtheta * sim_time_step;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查障碍物</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> mx, my;</span><br><span class="line">            <span class="keyword">if</span> (costmap_-&gt;<span class="built_in">worldToMap</span>(x, y, mx, my)) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">char</span> cost = costmap_-&gt;<span class="built_in">getCost</span>(mx, my);</span><br><span class="line">                traj.<span class="built_in">addPoint</span>(x, y, theta, vx, vtheta, cost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scoreTrajectory</span><span class="params">(<span class="type">const</span> base_local_planner::Trajectory&amp; traj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算到目标的距离和朝向</span></span><br><span class="line">        <span class="type">double</span> goal_x = goal_.pose.position.x;</span><br><span class="line">        <span class="type">double</span> goal_y = goal_.pose.position.y;</span><br><span class="line">        <span class="type">double</span> goal_theta = tf::<span class="built_in">getYaw</span>(goal_.pose.orientation);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取轨迹终点</span></span><br><span class="line">        <span class="type">double</span> end_x, end_y, end_theta;</span><br><span class="line">        traj.<span class="built_in">getEndpoint</span>(end_x, end_y, end_theta);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算到目标的距离</span></span><br><span class="line">        <span class="type">double</span> goal_dist = <span class="built_in">hypot</span>(end_x - goal_x, end_y - goal_y);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算朝向差异</span></span><br><span class="line">        <span class="type">double</span> heading = <span class="built_in">atan2</span>(goal_y - end_y, goal_x - end_x);</span><br><span class="line">        <span class="type">double</span> heading_diff = <span class="built_in">fabs</span>(angles::<span class="built_in">shortest_angular_distance</span>(end_theta, heading));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算障碍物代价</span></span><br><span class="line">        <span class="type">double</span> obstacle_cost = traj.<span class="built_in">getObstacleCost</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算最终得分</span></span><br><span class="line">        <span class="type">double</span> heading_score = (<span class="number">1.0</span> - heading_diff / M_PI) * goal_distance_bias_;</span><br><span class="line">        <span class="type">double</span> dist_score = <span class="built_in">exp</span>(<span class="number">-1.0</span> * goal_dist) * path_distance_bias_;</span><br><span class="line">        <span class="type">double</span> vel_score = traj.xv_ / max_vel_x_;</span><br><span class="line">        <span class="type">double</span> obstacle_score = (<span class="number">255.0</span> - obstacle_cost) / <span class="number">255.0</span> * occdist_scale_;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> heading_score + dist_score + vel_score + obstacle_score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;dwa_planner&quot;</span>);</span><br><span class="line">    DWAPlanner dwa_planner;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">20</span>)</span></span>; <span class="comment">// 控制频率20Hz</span></span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        dwa_planner.<span class="built_in">computeVelocityCommands</span>();</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        r.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="短期-TEB-Timed-Elastic-Band-算法"><a href="#短期-TEB-Timed-Elastic-Band-算法" class="headerlink" title="短期-TEB (Timed Elastic Band) 算法"></a>短期-TEB (Timed Elastic Band) 算法</h1><h2 id="1-基本介绍-3"><a href="#1-基本介绍-3" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>TEB (Timed Elastic Band) 算法是一种现代局部路径规划方法，通过将路径规划问题表述为优化问题来生成光滑、动态可行的轨迹。在ROS中，TEB通过<code>teb_local_planner</code>包实现，成为了一种流行的局部规划器选择，特别适合全向和阿克曼转向机器人。</p>
<h3 id="核心数学变量定义-3"><a href="#核心数学变量定义-3" class="headerlink" title="核心数学变量定义"></a>核心数学变量定义</h3><ul>
<li><strong>Q &#x3D; {q₁, q₂, …, qₙ}</strong>: 路径点序列，每个qᵢ表示机器人位姿 (x, y, θ)</li>
<li><strong>Δτ &#x3D; {Δt₁, Δt₂, …, Δtₙ₋₁}</strong>: 时间间隔序列，Δtᵢ是从qᵢ到qᵢ₊₁的时间</li>
<li><strong>B &#x3D; {Q, Δτ}</strong>: 时间弹性带，包含位姿序列和时间间隔</li>
<li><strong>f(B)</strong>: 优化目标函数，包含多个子目标</li>
<li><strong>h(B)</strong>: 等式约束，如起点和终点位姿</li>
<li><strong>g(B)</strong>: 不等式约束，如速度限制、加速度限制和碰撞避免</li>
<li><strong>v</strong>: 线速度</li>
<li><strong>ω</strong>: 角速度</li>
<li><strong>a</strong>: 线加速度</li>
<li><strong>α</strong>: 角加速度</li>
</ul>
<h2 id="2-基本思路与核心公式-2"><a href="#2-基本思路与核心公式-2" class="headerlink" title="2. 基本思路与核心公式"></a>2. 基本思路与核心公式</h2><h3 id="弹性橡皮筋：TEB算法的形象比喻"><a href="#弹性橡皮筋：TEB算法的形象比喻" class="headerlink" title="弹性橡皮筋：TEB算法的形象比喻"></a>弹性橡皮筋：TEB算法的形象比喻</h3><p>想象一条连接起点和终点的橡皮筋（初始路径），现在你需要调整这条橡皮筋，使它避开所有障碍物，且满足机器人的运动学和动力学约束。这条橡皮筋不仅具有空间弹性（可以调整位置和方向），还具有时间弹性（可以调整通过每段的时间）。</p>
<ol>
<li><p><strong>橡皮筋的初始化</strong>：<br>首先，你将橡皮筋沿着全局路径拉伸，放置一系列标记点（路径点），每个标记点带有位置、方向和时间信息。</p>
</li>
<li><p><strong>橡皮筋的调整</strong>：<br>现在，你对这条橡皮筋进行多方面的优化调整：</p>
<ul>
<li><strong>避开障碍物</strong>：当橡皮筋靠近障碍物时，会受到一个”推力”，使其远离障碍物。</li>
<li><strong>保持平滑</strong>：你不希望橡皮筋有急转弯，所以会尽量保持其平滑连续。</li>
<li><strong>遵守动力学约束</strong>：调整橡皮筋上的时间标记，确保机器人能够在指定时间内合理地从一个标记点移动到下一个标记点，不违反速度和加速度限制。</li>
<li><strong>保持轨迹最短</strong>：在满足上述所有约束的同时，尽量保持橡皮筋的长度最短。</li>
</ul>
</li>
<li><p><strong>数学优化过程</strong>：<br>以上调整过程可以表示为一个数学优化问题。你定义一个综合成本函数，包含多个子目标（路径长度、平滑度、障碍物距离等），然后使用优化算法（如梯度下降或更高级的求解器）找到最优解。</p>
</li>
<li><p><strong>迭代优化</strong>：<br>由于环境可能在不断变化，你需要周期性地重新评估和调整橡皮筋。每次迭代，都利用前一次的结果作为起点，加速收敛过程。</p>
</li>
</ol>
<h3 id="核心数学公式-3"><a href="#核心数学公式-3" class="headerlink" title="核心数学公式"></a>核心数学公式</h3><ol>
<li><p><strong>优化目标函数</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min f(B) = w₁·f_distance(B) + w₂·f_smoothness(B) + w₃·f_obstacle(B) + w₄·f_kinematics(B) + w₅·f_timeoptimal(B)</span><br></pre></td></tr></table></figure>

<p>其中各子目标为：</p>
<ul>
<li><p>路径长度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f_distance(B) = ∑ᵢ₌₁ⁿ⁻¹ ‖qᵢ₊₁ - qᵢ‖²</span><br></pre></td></tr></table></figure>
</li>
<li><p>平滑度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f_smoothness(B) = ∑ᵢ₌₂ⁿ⁻¹ ‖(qᵢ₊₁ - qᵢ) - (qᵢ - qᵢ₋₁)‖²</span><br></pre></td></tr></table></figure>
</li>
<li><p>障碍物距离：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f_obstacle(B) = ∑ᵢ₌₁ⁿ ∑ⱼ₌₁ᵐ φ(d(qᵢ, oⱼ))</span><br></pre></td></tr></table></figure>
<p>其中d(qᵢ, oⱼ)是机器人在位姿qᵢ时到障碍物oⱼ的距离，φ是代价函数。</p>
</li>
<li><p>动力学约束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f_kinematics(B) = ∑ᵢ₌₁ⁿ⁻¹ (φᵥ(vᵢ) + φω(ωᵢ) + φₐ(aᵢ) + φα(αᵢ))</span><br></pre></td></tr></table></figure>
<p>其中φᵥ, φω, φₐ, φα是速度和加速度的软约束代价函数。</p>
</li>
<li><p>时间优化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f_timeoptimal(B) = ∑ᵢ₌₁ⁿ⁻¹ Δtᵢ</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>约束条件</strong>:</p>
<ul>
<li><p>等式约束（起点和终点位姿）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h₁(B) = q₁ - qₛₜₐᵣₜ = 0</span><br><span class="line">h₂(B) = qₙ - qₑₙₐ = 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>不等式约束（速度限制）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g₁(B) = vᵢ - vₘₐₓ ≤ 0, ∀i</span><br><span class="line">g₂(B) = ωᵢ - ωₘₐₓ ≤ 0, ∀i</span><br></pre></td></tr></table></figure>
</li>
<li><p>加速度限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g₃(B) = aᵢ - aₘₐₓ ≤ 0, ∀i</span><br><span class="line">g₄(B) = αᵢ - αₘₐₓ ≤ 0, ∀i</span><br></pre></td></tr></table></figure>
</li>
<li><p>碰撞避免：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g₅(B) = d_min - d(qᵢ, oⱼ) ≤ 0, ∀i,j</span><br></pre></td></tr></table></figure>
<p>其中d_min是最小安全距离。</p>
</li>
</ul>
</li>
<li><p><strong>速度和加速度计算</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vᵢ = ‖qᵢ₊₁ - qᵢ‖ / Δtᵢ</span><br><span class="line">ωᵢ = Δθᵢ / Δtᵢ</span><br><span class="line">aᵢ = (vᵢ₊₁ - vᵢ) / (0.5 * (Δtᵢ + Δtᵢ₊₁))</span><br><span class="line">αᵢ = (ωᵢ₊₁ - ωᵢ) / (0.5 * (Δtᵢ + Δtᵢ₊₁))</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-数学推导-3"><a href="#3-数学推导-3" class="headerlink" title="3. 数学推导"></a>3. 数学推导</h2><p>TEB算法的核心是将路径规划问题转化为非线性优化问题，并通过数值方法求解。下面我们对算法的关键部分进行数学推导。</p>
<h3 id="1-优化问题的形式化"><a href="#1-优化问题的形式化" class="headerlink" title="1. 优化问题的形式化"></a>1. 优化问题的形式化</h3><p>TEB算法优化问题的标准形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">min f(B)</span><br><span class="line">s.t. h(B) = 0</span><br><span class="line">     g(B) ≤ 0</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>B &#x3D; {q₁, q₂, …, qₙ, Δt₁, Δt₂, …, Δtₙ₋₁} 是优化变量</li>
<li>f(B) 是要最小化的目标函数</li>
<li>h(B) 是等式约束</li>
<li>g(B) 是不等式约束</li>
</ul>
<h3 id="2-梯度推导"><a href="#2-梯度推导" class="headerlink" title="2. 梯度推导"></a>2. 梯度推导</h3><p>为了使用梯度下降类方法优化f(B)，需要计算目标函数对各优化变量的梯度。以路径长度子目标为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f_distance(B) = ∑ᵢ₌₁ⁿ⁻¹ ‖qᵢ₊₁ - qᵢ‖²</span><br></pre></td></tr></table></figure>

<p>对于位姿qᵢ的梯度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">∇qᵢ f_distance(B) = -2(qᵢ₊₁ - qᵢ) + 2(qᵢ - qᵢ₋₁), 1 &lt; i &lt; n</span><br><span class="line">∇q₁ f_distance(B) = -2(q₂ - q₁)</span><br><span class="line">∇qₙ f_distance(B) = 2(qₙ - qₙ₋₁)</span><br></pre></td></tr></table></figure>

<p>类似地，可以推导出目标函数对时间间隔Δtᵢ的梯度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">∇Δtᵢ f_distance(B) = 0  (因为f_distance不直接依赖于Δtᵢ)</span><br></pre></td></tr></table></figure>

<p>然而，动力学约束和时间优化子目标会对Δtᵢ产生梯度。</p>
<h3 id="3-约束处理"><a href="#3-约束处理" class="headerlink" title="3. 约束处理"></a>3. 约束处理</h3><p>TEB算法通常使用罚函数法或增广拉格朗日法处理约束。以速度约束为例，可以将其转化为软约束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">φᵥ(vᵢ) = &#123;</span><br><span class="line">    0,                       如果 vᵢ ≤ vₘₐₓ</span><br><span class="line">    λᵥ·(vᵢ - vₘₐₓ)²,        如果 vᵢ &gt; vₘₐₓ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中λᵥ是罚因子。</p>
<p>对于更复杂的算法实现，TEB通常采用稀疏非线性优化库（如g2o或Ceres）来求解。这些库使用高效的牛顿法或列文伯格-马夸特（Levenberg-Marquardt）算法处理非线性最小二乘问题。</p>
<h3 id="4-轨迹初始化"><a href="#4-轨迹初始化" class="headerlink" title="4. 轨迹初始化"></a>4. 轨迹初始化</h3><p>轨迹初始化对优化结果有重要影响。TEB通常采用以下初始化方法：</p>
<ol>
<li><p>基于全局路径的初始化：<br>将全局路径上的点均匀采样作为初始位姿序列 Q。</p>
</li>
<li><p>时间间隔初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Δtᵢ = ‖qᵢ₊₁ - qᵢ‖ / v_ref</span><br></pre></td></tr></table></figure>
<p>其中v_ref是期望参考速度。</p>
</li>
<li><p>轨迹热启动：<br>在连续的规划周期中，使用上一周期的优化结果作为新周期的初值，提高收敛速度。</p>
</li>
</ol>
<h3 id="5-最优性与收敛分析"><a href="#5-最优性与收敛分析" class="headerlink" title="5. 最优性与收敛分析"></a>5. 最优性与收敛分析</h3><p>TEB算法求解的是非线性优化问题，因此只能保证局部最优解，而非全局最优解。优化结果的质量取决于：</p>
<ol>
<li>初始值的选择：好的初始值可以引导优化到更好的局部最优解。</li>
<li>权重选择：各子目标的权重参数影响最终轨迹的特性。</li>
<li>迭代次数：足够的迭代次数确保优化充分收敛。</li>
</ol>
<p>理论上，在理想情况下（凸优化问题），梯度下降类算法会收敛到全局最优解。但由于TEB问题通常是非凸的，算法可能收敛到局部最优解。实践中，通过合理的初始化和参数调整，TEB能够生成满足实际需求的高质量轨迹。</p>
<h2 id="4-ROS源码实现-3"><a href="#4-ROS源码实现-3" class="headerlink" title="4. ROS源码实现"></a>4. ROS源码实现</h2><p>以下是TEB算法在ROS中的核心实现，基于<code>teb_local_planner</code>包：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;teb_local_planner/optimal_planner.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;teb_local_planner/teb_config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;costmap_2d/costmap_2d_ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tf/transform_listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nav_msgs/Path.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/PoseStamped.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TEBPlanner</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ROS接口</span></span><br><span class="line">    ros::NodeHandle nh_;</span><br><span class="line">    ros::Publisher vel_pub_;</span><br><span class="line">    ros::Publisher teb_pub_;</span><br><span class="line">    ros::Subscriber global_plan_sub_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TEB相关对象</span></span><br><span class="line">    teb_local_planner::TebConfig config_;</span><br><span class="line">    teb_local_planner::TebOptimalPlanner teb_planner_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 规划和导航相关对象</span></span><br><span class="line">    tf::TransformListener tf_;</span><br><span class="line">    costmap_2d::Costmap2DROS* costmap_ros_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 全局路径和机器人状态</span></span><br><span class="line">    std::vector&lt;geometry_msgs::PoseStamped&gt; global_plan_;</span><br><span class="line">    geometry_msgs::PoseStamped robot_pose_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TEBPlanner</span>() : <span class="built_in">nh_</span>(<span class="string">&quot;~&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化参数</span></span><br><span class="line">        config_ = teb_local_planner::<span class="built_in">TebConfig</span>();</span><br><span class="line">        <span class="built_in">loadParameters</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化ROS接口</span></span><br><span class="line">        vel_pub_ = nh_.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/cmd_vel&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        teb_pub_ = nh_.<span class="built_in">advertise</span>&lt;nav_msgs::Path&gt;(<span class="string">&quot;/teb_path&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        global_plan_sub_ = nh_.<span class="built_in">subscribe</span>(<span class="string">&quot;/move_base/GlobalPlanner/plan&quot;</span>, <span class="number">1</span>, &amp;TEBPlanner::globalPlanCallback, <span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化代价地图</span></span><br><span class="line">        costmap_ros_ = <span class="keyword">new</span> costmap_2d::<span class="built_in">Costmap2DROS</span>(<span class="string">&quot;local_costmap&quot;</span>, tf_);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化TEB规划器</span></span><br><span class="line">        teb_planner_.<span class="built_in">initialize</span>(config_, &amp;tf_, costmap_ros_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadParameters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 路径参数</span></span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;max_global_plan_lookahead_dist&quot;</span>, config_.trajectory.max_global_plan_lookahead_dist, <span class="number">3.0</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;global_plan_prune_distance&quot;</span>, config_.trajectory.global_plan_prune_distance, <span class="number">1.0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 机器人参数</span></span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;max_vel_x&quot;</span>, config_.robot.max_vel_x, <span class="number">0.4</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;max_vel_x_backwards&quot;</span>, config_.robot.max_vel_x_backwards, <span class="number">0.2</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;max_vel_theta&quot;</span>, config_.robot.max_vel_theta, <span class="number">0.3</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;acc_lim_x&quot;</span>, config_.robot.acc_lim_x, <span class="number">0.5</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;acc_lim_theta&quot;</span>, config_.robot.acc_lim_theta, <span class="number">0.5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 目标函数权重</span></span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;weight_kinematics_forward_drive&quot;</span>, config_.optim.weight_kinematics_forward_drive, <span class="number">1.0</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;weight_kinematics_turning_radius&quot;</span>, config_.optim.weight_kinematics_turning_radius, <span class="number">1.0</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;weight_obstacle&quot;</span>, config_.optim.weight_obstacle, <span class="number">50.0</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;weight_inflation&quot;</span>, config_.optim.weight_inflation, <span class="number">0.1</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;weight_adapt_factor&quot;</span>, config_.optim.weight_adapt_factor, <span class="number">2.0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 障碍物参数</span></span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;min_obstacle_dist&quot;</span>, config_.obstacles.min_obstacle_dist, <span class="number">0.5</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;inflation_dist&quot;</span>, config_.obstacles.inflation_dist, <span class="number">0.6</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 优化参数</span></span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;no_inner_iterations&quot;</span>, config_.optim.no_inner_iterations, <span class="number">5</span>);</span><br><span class="line">        nh_.<span class="built_in">param</span>(<span class="string">&quot;no_outer_iterations&quot;</span>, config_.optim.no_outer_iterations, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">globalPlanCallback</span><span class="params">(<span class="type">const</span> nav_msgs::Path::ConstPtr&amp; msg)</span> </span>&#123;</span><br><span class="line">        global_plan_ = msg-&gt;poses;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">getRobotPose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tf::StampedTransform transform;</span><br><span class="line">            tf_.<span class="built_in">lookupTransform</span>(costmap_ros_-&gt;<span class="built_in">getGlobalFrameID</span>(), costmap_ros_-&gt;<span class="built_in">getBaseFrameID</span>(), </span><br><span class="line">                               ros::<span class="built_in">Time</span>(<span class="number">0</span>), transform);</span><br><span class="line">            </span><br><span class="line">            robot_pose_.header.frame_id = costmap_ros_-&gt;<span class="built_in">getGlobalFrameID</span>();</span><br><span class="line">            robot_pose_.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">            robot_pose_.pose.position.x = transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>();</span><br><span class="line">            robot_pose_.pose.position.y = transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>();</span><br><span class="line">            robot_pose_.pose.orientation = tf::<span class="built_in">createQuaternionMsgFromYaw</span>(tf::<span class="built_in">getYaw</span>(transform.<span class="built_in">getRotation</span>()));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="built_in">catch</span> (tf::TransformException&amp; ex) &#123;</span><br><span class="line">            <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Could not get robot pose: %s&quot;</span>, ex.<span class="built_in">what</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">plan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否有全局路径</span></span><br><span class="line">        <span class="keyword">if</span> (global_plan_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Global plan is empty&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取机器人当前位姿</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">getRobotPose</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 准备优化</span></span><br><span class="line">        teb_planner_.<span class="built_in">updateRobotPose</span>(robot_pose_);</span><br><span class="line">        teb_planner_.<span class="built_in">updateGlobalPlan</span>(global_plan_);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置障碍物</span></span><br><span class="line">        std::vector&lt;teb_local_planner::ObstaclePtr&gt; obstacles;</span><br><span class="line">        teb_planner_.<span class="built_in">updateObstacles</span>(obstacles);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行优化</span></span><br><span class="line">        teb_planner_.<span class="built_in">plan</span>(obstacles);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取优化后的轨迹</span></span><br><span class="line">        std::vector&lt;geometry_msgs::PoseStamped&gt; teb_poses;</span><br><span class="line">        std::vector&lt;geometry_msgs::TwistStamped&gt; teb_velocities;</span><br><span class="line">        teb_planner_.<span class="built_in">getFullTrajectory</span>(teb_poses, teb_velocities);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发布轨迹可视化</span></span><br><span class="line">        <span class="built_in">publishTEBPath</span>(teb_poses);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取并发布控制命令</span></span><br><span class="line">        <span class="keyword">if</span> (!teb_velocities.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            geometry_msgs::Twist cmd_vel = teb_velocities.<span class="built_in">front</span>().twist;</span><br><span class="line">            vel_pub_.<span class="built_in">publish</span>(cmd_vel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publishTEBPath</span><span class="params">(<span class="type">const</span> std::vector&lt;geometry_msgs::PoseStamped&gt;&amp; poses)</span> </span>&#123;</span><br><span class="line">        nav_msgs::Path path;</span><br><span class="line">        path.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        path.header.frame_id = costmap_ros_-&gt;<span class="built_in">getGlobalFrameID</span>();</span><br><span class="line">        path.poses = poses;</span><br><span class="line">        teb_pub_.<span class="built_in">publish</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;teb_planner&quot;</span>);</span><br><span class="line">    TEBPlanner teb_planner;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 控制频率10Hz</span></span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        teb_planner.<span class="built_in">plan</span>();</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        r.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-TEB算法的扩展与特性"><a href="#5-TEB算法的扩展与特性" class="headerlink" title="5. TEB算法的扩展与特性"></a>5. TEB算法的扩展与特性</h2><p>TEB算法有许多扩展和特殊功能，使其在ROS导航中特别有价值：</p>
<h3 id="1-机器人类型适应性"><a href="#1-机器人类型适应性" class="headerlink" title="1. 机器人类型适应性"></a>1. 机器人类型适应性</h3><p>TEB能够处理多种类型的机器人运动学模型：</p>
<ul>
<li><strong>全向机器人</strong>：通过适当的约束函数实现全向运动</li>
<li><strong>差速驱动</strong>：增加非完整约束，限制侧向速度为零</li>
<li><strong>阿克曼转向</strong>：增加转弯半径约束，适用于汽车类型机器人</li>
<li><strong>推挽式机器人</strong>：处理前进和后退切换的特殊约束</li>
</ul>
<h3 id="2-动态避障增强"><a href="#2-动态避障增强" class="headerlink" title="2. 动态避障增强"></a>2. 动态避障增强</h3><p>TEB能够高效处理动态环境中的障碍物：</p>
<ul>
<li><strong>预测避障</strong>：考虑障碍物的运动趋势，提前规划避让路径</li>
<li><strong>社交约束</strong>：在人机共存环境中，考虑人的舒适区和社交规则</li>
<li><strong>反应式避障</strong>：实时调整轨迹，应对突发障碍物</li>
</ul>
<h3 id="3-H-签名启发式"><a href="#3-H-签名启发式" class="headerlink" title="3. H-签名启发式"></a>3. H-签名启发式</h3><p>为解决局部最小值问题，TEB采用H-签名启发式算法：</p>
<ul>
<li>通过分析障碍物相对于全局路径的位置（左侧或右侧）</li>
<li>确定机器人应该从哪一侧绕过障碍物</li>
<li>有效避免局部最小值陷阱和震荡行为</li>
</ul>
<h3 id="4-与全局规划器的无缝集成"><a href="#4-与全局规划器的无缝集成" class="headerlink" title="4. 与全局规划器的无缝集成"></a>4. 与全局规划器的无缝集成</h3><p>TEB可以智能利用全局规划信息：</p>
<ul>
<li><strong>路径跟踪行为</strong>：当无障碍物时，平滑跟踪全局路径</li>
<li><strong>局部避障行为</strong>：当检测到障碍物时，优先保证安全，可能暂时偏离全局路径</li>
<li><strong>热启动能力</strong>：使用之前的优化结果作为初值，提高计算效率</li>
</ul>
<p>TEB算法的这些特性使其成为ROS导航栈中功能最全面的局部规划器之一，特别适合在复杂、动态环境中的智能移动机器人应用。</p>
<h2 id="定位-卡尔曼滤波"><a href="#定位-卡尔曼滤波" class="headerlink" title="定位-卡尔曼滤波"></a>定位-卡尔曼滤波</h2><h1 id="卡尔曼滤波：智慧导航员的确定性航行"><a href="#卡尔曼滤波：智慧导航员的确定性航行" class="headerlink" title="卡尔曼滤波：智慧导航员的确定性航行"></a>卡尔曼滤波：智慧导航员的确定性航行</h1><h1 id="机器人定位中的滤波算法"><a href="#机器人定位中的滤波算法" class="headerlink" title="机器人定位中的滤波算法"></a>机器人定位中的滤波算法</h1><h2 id="1-卡尔曼滤波"><a href="#1-卡尔曼滤波" class="headerlink" title="1. 卡尔曼滤波"></a>1. 卡尔曼滤波</h2><h3 id="1-1-基本介绍"><a href="#1-1-基本介绍" class="headerlink" title="1.1 基本介绍"></a>1.1 基本介绍</h3><p>卡尔曼滤波是一种高效的递归滤波器，用于估计动态系统的状态。在机器人定位中，它通过融合测量值与预测值来得到最优状态估计。卡尔曼滤波基于两个关键假设：系统是线性的，噪声是高斯分布的。</p>
<p><strong>基本数学变量</strong>：</p>
<ul>
<li>$$\hat{x}$$：状态估计向量，如机器人的位置、速度</li>
<li>$$P$$：状态协方差矩阵，表示估计的不确定性</li>
<li>$$F$$：状态转移矩阵，描述状态如何随时间变化</li>
<li>$$B$$：控制输入矩阵</li>
<li>$$u$$：控制输入向量</li>
<li>$$Q$$：过程噪声协方差</li>
<li>$$H$$：观测矩阵</li>
<li>$$z$$：观测向量</li>
<li>$$R$$：观测噪声协方差</li>
<li>$$K$$：卡尔曼增益</li>
</ul>
<h3 id="1-2-基本思路"><a href="#1-2-基本思路" class="headerlink" title="1.2 基本思路"></a>1.2 基本思路</h3><p>可以将卡尔曼滤波比作一位精通数学的导航员，他通过精确计算来确定位置。</p>
<p><strong>导航员的定位过程</strong>：</p>
<ol>
<li><p><strong>预测阶段</strong>：导航员根据上一时刻位置和移动方向，预测当前位置</p>
<ul>
<li>“根据之前的位置和我们向北走了100米，我估计我们现在应该在河边”</li>
<li>但他知道这个预测有不确定性：指南针可能有偏差，步行距离可能不准确</li>
</ul>
</li>
<li><p><strong>测量阶段</strong>：导航员观测周围地标</p>
<ul>
<li>“我看到西边约200米处有座小山，东边约150米处有棵高橡树”</li>
<li>这些观测也存在误差：视线可能受阻，测距可能不准确</li>
</ul>
</li>
<li><p><strong>更新阶段</strong>：导航员综合预测和观测信息，得出最终位置估计</p>
<ul>
<li>若预测比观测更可靠，他更依赖预测</li>
<li>若观测比预测更可靠，他更依赖观测</li>
<li>“综合考虑，我们最可能位于河边稍北100米的平地上”</li>
</ul>
</li>
</ol>
<p><strong>核心公式</strong>：</p>
<p>预测阶段：</p>
<ul>
<li>状态预测：$$\hat{x}<em>{t|t-1} &#x3D; F_t \hat{x}</em>{t-1|t-1} + B_t u_t$$</li>
<li>协方差预测：$$P_{t|t-1} &#x3D; F_t P_{t-1|t-1} F_t^T + Q_t$$</li>
</ul>
<p>更新阶段：</p>
<ul>
<li>卡尔曼增益：$$K_t &#x3D; P_{t|t-1} H_t^T (H_t P_{t|t-1} H_t^T + R_t)^{-1}$$</li>
<li>状态更新：$$\hat{x}<em>{t|t} &#x3D; \hat{x}</em>{t|t-1} + K_t (z_t - H_t \hat{x}_{t|t-1})$$</li>
<li>协方差更新：$$P_{t|t} &#x3D; (I - K_t H_t) P_{t|t-1}$$</li>
</ul>
<h3 id="1-3-数学推导"><a href="#1-3-数学推导" class="headerlink" title="1.3 数学推导"></a>1.3 数学推导</h3><p>卡尔曼滤波的数学推导基于贝叶斯估计框架，目标是最小化估计误差的协方差。</p>
<ol>
<li><p><strong>初始条件</strong>：</p>
<ul>
<li>初始状态估计 $$\hat{x}<em>{0|0}$$ 和初始协方差 $$P</em>{0|0}$$</li>
</ul>
</li>
<li><p><strong>预测步骤推导</strong>：</p>
<ul>
<li>假设系统动态模型：$$x_t &#x3D; F_t x_{t-1} + B_t u_t + w_t$$，其中 $$w_t \sim N(0, Q_t)$$</li>
<li>由期望的线性性：$$E[x_t | y_{1:t-1}] &#x3D; E[F_t x_{t-1} + B_t u_t + w_t | y_{1:t-1}] &#x3D; F_t E[x_{t-1} | y_{1:t-1}] + B_t u_t$$</li>
<li>因此状态预测：$$\hat{x}<em>{t|t-1} &#x3D; F_t \hat{x}</em>{t-1|t-1} + B_t u_t$$</li>
<li>预测误差：$$e_{t|t-1} &#x3D; x_t - \hat{x}<em>{t|t-1} &#x3D; F_t (x</em>{t-1} - \hat{x}_{t-1|t-1}) + w_t$$</li>
<li>预测误差协方差：$$P_{t|t-1} &#x3D; E[e_{t|t-1} e_{t|t-1}^T] &#x3D; F_t P_{t-1|t-1} F_t^T + Q_t$$</li>
</ul>
</li>
<li><p><strong>更新步骤推导</strong>：</p>
<ul>
<li>观测模型：$$z_t &#x3D; H_t x_t + v_t$$，其中 $$v_t \sim N(0, R_t)$$</li>
<li>最优估计应为后验均值：$$\hat{x}<em>{t|t} &#x3D; E[x_t | y</em>{1:t}]$$</li>
<li>假设最优估计形式：$$\hat{x}<em>{t|t} &#x3D; \hat{x}</em>{t|t-1} + K_t (z_t - H_t \hat{x}_{t|t-1})$$</li>
<li>对于卡尔曼增益 $$K_t$$，我们希望最小化更新后的协方差 $$P_{t|t} &#x3D; E[(x_t - \hat{x}<em>{t|t})(x_t - \hat{x}</em>{t|t})^T]$$</li>
<li>将 $$\hat{x}<em>{t|t}$$ 代入 $$P</em>{t|t}$$ 并求导，令导数为零：$$\frac{\partial tr(P_{t|t})}{\partial K_t} &#x3D; 0$$</li>
<li>解得：$$K_t &#x3D; P_{t|t-1} H_t^T (H_t P_{t|t-1} H_t^T + R_t)^{-1}$$</li>
<li>最后，更新协方差：$$P_{t|t} &#x3D; (I - K_t H_t) P_{t|t-1}$$</li>
</ul>
</li>
</ol>
<h3 id="1-4-ROS源码实现"><a href="#1-4-ROS源码实现" class="headerlink" title="1.4 ROS源码实现"></a>1.4 ROS源码实现</h3><p>以下是在ROS中实现卡尔曼滤波的核心部分代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KalmanFilter::predict</span><span class="params">(<span class="type">double</span> dt)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 更新状态转移矩阵</span></span><br><span class="line">  <span class="built_in">F_</span>(<span class="number">0</span>, <span class="number">2</span>) = -<span class="built_in">x_</span>(<span class="number">3</span>) * <span class="built_in">sin</span>(<span class="built_in">x_</span>(<span class="number">2</span>)) * dt;</span><br><span class="line">  <span class="built_in">F_</span>(<span class="number">0</span>, <span class="number">3</span>) = <span class="built_in">cos</span>(<span class="built_in">x_</span>(<span class="number">2</span>)) * dt;</span><br><span class="line">  <span class="built_in">F_</span>(<span class="number">1</span>, <span class="number">2</span>) = <span class="built_in">x_</span>(<span class="number">3</span>) * <span class="built_in">cos</span>(<span class="built_in">x_</span>(<span class="number">2</span>)) * dt;</span><br><span class="line">  <span class="built_in">F_</span>(<span class="number">1</span>, <span class="number">3</span>) = <span class="built_in">sin</span>(<span class="built_in">x_</span>(<span class="number">2</span>)) * dt;</span><br><span class="line">  <span class="built_in">F_</span>(<span class="number">2</span>, <span class="number">4</span>) = dt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 预测状态</span></span><br><span class="line">  <span class="built_in">x_</span>(<span class="number">0</span>) += <span class="built_in">x_</span>(<span class="number">3</span>) * <span class="built_in">cos</span>(<span class="built_in">x_</span>(<span class="number">2</span>)) * dt;</span><br><span class="line">  <span class="built_in">x_</span>(<span class="number">1</span>) += <span class="built_in">x_</span>(<span class="number">3</span>) * <span class="built_in">sin</span>(<span class="built_in">x_</span>(<span class="number">2</span>)) * dt;</span><br><span class="line">  <span class="built_in">x_</span>(<span class="number">2</span>) += <span class="built_in">x_</span>(<span class="number">4</span>) * dt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 预测协方差</span></span><br><span class="line">  P_ = F_ * P_ * F_.<span class="built_in">transpose</span>() + Q_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KalmanFilter::update</span><span class="params">(<span class="type">const</span> Eigen::VectorXd&amp; z)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 计算卡尔曼增益</span></span><br><span class="line">  Eigen::MatrixXd K = P_ * H_.<span class="built_in">transpose</span>() * </span><br><span class="line">                      (H_ * P_ * H_.<span class="built_in">transpose</span>() + R_).<span class="built_in">inverse</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算残差</span></span><br><span class="line">  Eigen::VectorXd y = z - H_ * x_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 归一化角度残差</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">y</span>(<span class="number">2</span>) &gt; M_PI) <span class="built_in">y</span>(<span class="number">2</span>) -= <span class="number">2.0</span> * M_PI;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">y</span>(<span class="number">2</span>) &lt; -M_PI) <span class="built_in">y</span>(<span class="number">2</span>) += <span class="number">2.0</span> * M_PI;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 更新状态</span></span><br><span class="line">  x_ = x_ + K * y;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 更新协方差</span></span><br><span class="line">  P_ = (Eigen::MatrixXd::<span class="built_in">Identity</span>(<span class="number">5</span>, <span class="number">5</span>) - K * H_) * P_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-扩展卡尔曼滤波与无迹卡尔曼滤波"><a href="#1-5-扩展卡尔曼滤波与无迹卡尔曼滤波" class="headerlink" title="1.5 扩展卡尔曼滤波与无迹卡尔曼滤波"></a>1.5 扩展卡尔曼滤波与无迹卡尔曼滤波</h3><p>对于非线性系统，标准卡尔曼滤波不再适用，有两种主要扩展：</p>
<p>**扩展卡尔曼滤波(EKF)**：</p>
<ul>
<li>通过一阶泰勒展开线性化非线性函数</li>
<li>核心思想：在当前估计点处对非线性函数进行局部线性化</li>
<li>局限性：对高度非线性系统可能表现不佳</li>
</ul>
<p>**无迹卡尔曼滤波(UKF)**：</p>
<ul>
<li>使用一组精心选择的采样点（sigma点）来捕捉非线性变换</li>
<li>无需显式计算雅可比矩阵，降低了实现复杂度</li>
<li>对于中等非线性系统，通常比EKF更准确</li>
</ul>
<h2 id="2-Rao-Blackwellized粒子滤波"><a href="#2-Rao-Blackwellized粒子滤波" class="headerlink" title="2. Rao-Blackwellized粒子滤波"></a>2. Rao-Blackwellized粒子滤波</h2><h3 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1 基本介绍"></a>2.1 基本介绍</h3><p>Rao-Blackwellized粒子滤波(RBPF)是一种混合滤波方法，结合了采样技术与解析解。它基于Rao-Blackwell定理，通过降低采样维度来提高滤波效率。</p>
<p><strong>基本数学变量</strong>：</p>
<ul>
<li>$$r_{0:t}$$：需要通过粒子滤波估计的状态部分</li>
<li>$$s_{0:t}$$：在已知$$r_{0:t}$$条件下可解析计算的状态部分</li>
<li>$$y_{1:t}$$：观测序列</li>
<li>$$w_t^{(i)}$$：第i个粒子的权重</li>
<li>$$N$$：粒子数量</li>
</ul>
<h3 id="2-2-基本思路"><a href="#2-2-基本思路" class="headerlink" title="2.2 基本思路"></a>2.2 基本思路</h3><p>RBPF可比作一支有明确分工的探险队，解决复杂的定位与建图问题。</p>
<p><strong>探险队的分工</strong>：</p>
<ol>
<li><p><strong>探险家小队（粒子滤波）</strong>：多名探险家尝试不同的路径$$r_{0:t}$$</p>
<ul>
<li>每人负责一条可能的路线，如”左转-直走-右转”</li>
<li>根据观测评估每条路径的可能性</li>
</ul>
</li>
<li><p><strong>地标专家（解析方法）</strong>：每位探险家带一位专家，专注于精确测量地标$$s_{0:t}$$</p>
<ul>
<li>一旦确定路径，专家就能精确计算地标位置</li>
<li>通常使用高效的解析方法如卡尔曼滤波</li>
</ul>
</li>
</ol>
<p>这种分工使RBPF特别适合SLAM（同时定位与建图）问题，降低了计算负担。</p>
<p><strong>核心公式</strong>：</p>
<p>后验分布分解：<br>$$p(r_{0:t}, s_{0:t}|y_{1:t}) &#x3D; p(s_{0:t}|r_{0:t}, y_{1:t}) \cdot p(r_{0:t}|y_{1:t})$$</p>
<p>RBPF表示：<br>$$p(r_{0:t}, s_{0:t}|y_{1:t}) \approx \sum_{i&#x3D;1}^{N} w_t^{(i)}\delta(r_{0:t} - r_{0:t}^{(i)})p(s_{0:t}|r_{0:t}^{(i)}, y_{1:t})$$</p>
<h3 id="2-3-数学推导"><a href="#2-3-数学推导" class="headerlink" title="2.3 数学推导"></a>2.3 数学推导</h3><p>RBPF的数学推导基于后验分布的分解与条件概率。</p>
<ol>
<li><p><strong>后验分布分解</strong>：</p>
<ul>
<li>应用贝叶斯法则：$$p(r_{0:t}, s_{0:t}|y_{1:t}) &#x3D; p(s_{0:t}|r_{0:t}, y_{1:t}) \cdot p(r_{0:t}|y_{1:t})$$</li>
<li>这将复杂的联合估计分解为两步：先估计$$r_{0:t}$$，再在给定$$r_{0:t}$$的条件下估计$$s_{0:t}$$</li>
</ul>
</li>
<li><p><strong>机器人位姿估计（粒子滤波部分）</strong>：</p>
<ul>
<li>时间更新：$$p(r_{0:t}|y_{1:t-1}) &#x3D; \int p(r_t|r_{t-1})p(r_{0:t-1}|y_{1:t-1})dr_{t-1}$$</li>
<li>测量更新：$$p(r_{0:t}|y_{1:t}) \propto p(y_t|r_t)p(r_{0:t}|y_{1:t-1})$$</li>
<li>粒子表示：$$p(r_{0:t}|y_{1:t}) \approx \sum_{i&#x3D;1}^{N} w_t^{(i)}\delta(r_{0:t} - r_{0:t}^{(i)})$$</li>
</ul>
</li>
<li><p><strong>地图估计（解析部分）</strong>：</p>
<ul>
<li>对每个粒子$$i$$，我们有$$p(s_{0:t}|r_{0:t}^{(i)}, y_{1:t})$$</li>
<li>若地图特征之间条件独立：$$p(s_{0:t}|r_{0:t}, y_{1:t}) &#x3D; \prod_{j&#x3D;1}^{M} p(s_{0:t}^j|r_{0:t}, y_{1:t})$$</li>
<li>对于线性高斯模型，每个特征$$j$$的条件概率$$p(s_{0:t}^j|r_{0:t}, y_{1:t})$$可通过卡尔曼滤波解析求解</li>
</ul>
</li>
<li><p><strong>最终估计</strong>：</p>
<ul>
<li>地图估计：$$E[s_t|y_{1:t}] \approx \sum_{i&#x3D;1}^{N} w_t^{(i)}E[s_t|r_{0:t}^{(i)}, y_{1:t}]$$</li>
<li>这是一个加权平均，权重由粒子权重决定</li>
</ul>
</li>
</ol>
<h3 id="2-4-ROS源码实现"><a href="#2-4-ROS源码实现" class="headerlink" title="2.4 ROS源码实现"></a>2.4 ROS源码实现</h3><p>以下是在ROS中实现RBPF的核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RBPFSlam::laserCallback</span><span class="params">(<span class="type">const</span> sensor_msgs::LaserScan::ConstPtr&amp; msg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对每个粒子</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_particles_; i++) &#123;</span><br><span class="line">    <span class="comment">// 1. 用粒子的位姿预测激光扫描结果</span></span><br><span class="line">    <span class="keyword">auto</span> predicted_scan = <span class="built_in">predictScan</span>(particles_[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 计算权重（基于激光扫描匹配的似然）</span></span><br><span class="line">    particles_[i].weight *= <span class="built_in">calculateLikelihood</span>(*msg, predicted_scan);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 更新地图（Rao-Blackwellized部分，解析更新地图）</span></span><br><span class="line">    <span class="built_in">updateMap</span>(particles_[i], *msg);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 归一化权重</span></span><br><span class="line">  <span class="built_in">normalizeWeights</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重采样</span></span><br><span class="line">  <span class="built_in">resample</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发布估计的位姿</span></span><br><span class="line">  <span class="built_in">publishPose</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对给定粒子解析更新地图（Rao-Blackwellized核心部分）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RBPFSlam::updateMap</span><span class="params">(Particle&amp; p, <span class="type">const</span> sensor_msgs::LaserScan&amp; scan)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从激光扫描中提取特征点</span></span><br><span class="line">  <span class="keyword">auto</span> features = <span class="built_in">extractFeatures</span>(scan);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对每个特征点，使用卡尔曼滤波更新地图</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; feature : features) &#123;</span><br><span class="line">    <span class="comment">// 数据关联：确定特征对应地图中的哪个地标</span></span><br><span class="line">    <span class="type">int</span> landmark_id = <span class="built_in">associateFeature</span>(p, feature);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (landmark_id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 已知地标，更新</span></span><br><span class="line">      <span class="built_in">updateLandmark</span>(p, landmark_id, feature);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 新地标，添加</span></span><br><span class="line">      <span class="built_in">addNewLandmark</span>(p, feature);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-粒子群优化"><a href="#3-粒子群优化" class="headerlink" title="3. 粒子群优化"></a>3. 粒子群优化</h2><h3 id="3-1-基本介绍"><a href="#3-1-基本介绍" class="headerlink" title="3.1 基本介绍"></a>3.1 基本介绍</h3><p>粒子群优化(PSO)是一种受鸟群鱼群等群体行为启发的全局优化算法。在机器人领域，PSO常用于路径规划和参数优化。</p>
<p><strong>基本数学变量</strong>：</p>
<ul>
<li>$$X_i^t$$：第i个粒子在时刻t的位置</li>
<li>$$V_i^t$$：第i个粒子在时刻t的速度</li>
<li>$$P_i$$：第i个粒子的个体最优位置</li>
<li>$$G$$：全局最优位置</li>
<li>$$w$$：惯性权重</li>
<li>$$c_1, c_2$$：加速常数</li>
<li>$$r_1, r_2$$：随机数</li>
</ul>
<h3 id="3-2-基本思路"><a href="#3-2-基本思路" class="headerlink" title="3.2 基本思路"></a>3.2 基本思路</h3><p>粒子群优化可比作一群智慧探险家共同寻宝的过程。</p>
<p><strong>探险团队的智慧寻宝</strong>：</p>
<ol>
<li><p><strong>个体经验</strong>：每位探险家记住自己发现过的最佳地点</p>
<ul>
<li>“我曾经爬过的最高点是东边那座小山”</li>
</ul>
</li>
<li><p><strong>集体智慧</strong>：团队共享信息，所有人知道谁找到了最佳位置</p>
<ul>
<li>“李队长在北部发现了一座高山，目前是我们找到的最高点”</li>
</ul>
</li>
<li><p><strong>移动决策</strong>：探险家决定下一步行动时，考虑三个因素：</p>
<ul>
<li><strong>惯性</strong>：继续沿当前方向探索<ul>
<li>“我正往西走，就继续往西走一段看看”</li>
</ul>
</li>
<li><strong>个体记忆</strong>：向自己曾发现的最佳地点方向移动<ul>
<li>“也许我应该回到东边那座小山，再从那里开始探索”</li>
</ul>
</li>
<li><strong>社会影响</strong>：向团队发现的最佳地点方向移动<ul>
<li>“或者我应该向北部李队长发现的高山方向走”</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>核心公式</strong>：</p>
<p>速度更新：<br>$$V_i^{t+1} &#x3D; w \cdot V_i^t + c_1 \cdot r_1 \cdot (P_i - X_i^t) + c_2 \cdot r_2 \cdot (G - X_i^t)$$</p>
<p>位置更新：<br>$$X_i^{t+1} &#x3D; X_i^t + V_i^{t+1}$$</p>
<h3 id="3-3-数学推导"><a href="#3-3-数学推导" class="headerlink" title="3.3 数学推导"></a>3.3 数学推导</h3><p>PSO的数学推导相对直接，基于位置和速度的迭代更新。</p>
<ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>随机初始化粒子位置$$X_i^0$$和速度$$V_i^0$$</li>
<li>设置初始个体最优$$P_i &#x3D; X_i^0$$</li>
<li>确定初始全局最优$$G &#x3D; \arg\max_i f(X_i^0)$$，其中$$f$$是评价函数</li>
</ul>
</li>
<li><p><strong>迭代更新</strong>：</p>
<ul>
<li>速度更新包含三个部分：<ul>
<li>惯性项：$$w \cdot V_i^t$$，保持当前移动趋势</li>
<li>认知项：$$c_1 \cdot r_1 \cdot (P_i - X_i^t)$$，向个体最优移动</li>
<li>社会项：$$c_2 \cdot r_2 \cdot (G - X_i^t)$$，向全局最优移动</li>
</ul>
</li>
<li>位置更新直接基于速度：$$X_i^{t+1} &#x3D; X_i^t + V_i^{t+1}$$</li>
</ul>
</li>
<li><p><strong>最优值更新</strong>：</p>
<ul>
<li>个体最优更新：若$$f(X_i^{t+1}) &gt; f(P_i)$$，则$$P_i &#x3D; X_i^{t+1}$$</li>
<li>全局最优更新：若存在$$i$$使得$$f(X_i^{t+1}) &gt; f(G)$$，则$$G &#x3D; X_i^{t+1}$$</li>
</ul>
</li>
<li><p><strong>终止条件</strong>：</p>
<ul>
<li>达到最大迭代次数或满足收敛条件时停止</li>
</ul>
</li>
</ol>
<h3 id="3-4-ROS源码实现"><a href="#3-4-ROS源码实现" class="headerlink" title="3.4 ROS源码实现"></a>3.4 ROS源码实现</h3><p>以下是在ROS中实现PSO路径规划的核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PSOPathPlanner::updateParticle</span><span class="params">(Particle&amp; p)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> dim = p.position.<span class="built_in">size</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; dim - <span class="number">2</span>; i++) &#123; <span class="comment">// 跳过起点和终点</span></span><br><span class="line">    <span class="comment">// 更新速度</span></span><br><span class="line">    <span class="type">double</span> r1 = <span class="built_in">dis_</span>(gen_);</span><br><span class="line">    <span class="type">double</span> r2 = <span class="built_in">dis_</span>(gen_);</span><br><span class="line">    </span><br><span class="line">    p.velocity[i] = w_ * p.velocity[i] + </span><br><span class="line">                   c1_ * r1 * (p.best_position[i] - p.position[i]) + </span><br><span class="line">                   c2_ * r2 * (global_best_position_[i] - p.position[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新位置</span></span><br><span class="line">    p.position[i] += p.velocity[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保粒子位置在地图范围内</span></span><br><span class="line">    <span class="built_in">constrainToMap</span>(p.position[i], p.position[i<span class="number">+1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">PSOPathPlanner::evaluateFitness</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; position)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> fitness = <span class="number">0.0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 路径长度（越短越好）</span></span><br><span class="line">  <span class="type">double</span> path_length = <span class="built_in">calculatePathLength</span>(position);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 路径平滑度（转弯越少越好）</span></span><br><span class="line">  <span class="type">double</span> smoothness = <span class="built_in">calculateSmoothness</span>(position);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 碰撞检测（越远离障碍物越好）</span></span><br><span class="line">  <span class="type">double</span> collision_cost = <span class="built_in">calculateCollisionCost</span>(position);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 综合评分（转换为正值适应度）</span></span><br><span class="line">  fitness = <span class="number">-1.0</span> * (<span class="number">0.5</span> * path_length + <span class="number">0.3</span> * smoothness + collision_cost);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> fitness;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PSOPathPlanner::planPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (iteration_ = <span class="number">0</span>; iteration_ &lt; max_iterations_; iteration_++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_particles_; i++) &#123;</span><br><span class="line">      <span class="comment">// 更新粒子的速度和位置</span></span><br><span class="line">      <span class="built_in">updateParticle</span>(particles_[i]);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 计算新的适应度</span></span><br><span class="line">      particles_[i].fitness = <span class="built_in">evaluateFitness</span>(particles_[i].position);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 更新个体最优</span></span><br><span class="line">      <span class="keyword">if</span> (particles_[i].fitness &gt; particles_[i].best_fitness) &#123;</span><br><span class="line">        particles_[i].best_fitness = particles_[i].fitness;</span><br><span class="line">        particles_[i].best_position = particles_[i].position;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新全局最优</span></span><br><span class="line">        <span class="keyword">if</span> (particles_[i].fitness &gt; global_best_fitness_) &#123;</span><br><span class="line">          global_best_fitness_ = particles_[i].fitness;</span><br><span class="line">          global_best_position_ = particles_[i].position;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可视化当前最优路径</span></span><br><span class="line">    <span class="built_in">visualizePath</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这三种滤波算法在机器人定位中各有优势：</p>
<ol>
<li><p><strong>卡尔曼滤波</strong>：适用于线性高斯系统，计算效率高，适合实时应用；对于非线性系统，可使用EKF或UKF扩展。</p>
</li>
<li><p><strong>Rao-Blackwellized粒子滤波</strong>：通过降低采样维度提高效率，特别适合SLAM问题；结合了采样方法与解析解的优势。</p>
</li>
<li><p><strong>粒子群优化</strong>：全局优化算法，适合寻找多维空间中的最优解；在路径规划和参数优化中表现出色。</p>
</li>
</ol>
<h1 id="extern-problem-卡尔曼滤波里面两种噪音能不能统一"><a href="#extern-problem-卡尔曼滤波里面两种噪音能不能统一" class="headerlink" title="extern problem:卡尔曼滤波里面两种噪音能不能统一:"></a>extern problem:卡尔曼滤波里面两种噪音能不能统一:</h1><p>因为两种噪音，一种来自于过程，一种来自于观测，不好统一，但是其实是有机会统一的:<br>但是:</p>
<p>卡尔曼滤波确实可以被视为一个最小二乘优化问题，其中同时考虑了过程噪声和测量噪声。这种最小二乘公式化是卡尔曼滤波推导的几种方法之一。</p>
<p>从最小二乘角度看，卡尔曼滤波的核心是通过最小化以下误差函数来获得最优估计：</p>
<p>$$$$\min_{\hat{x}} E[(x - \hat{x})^T(x - \hat{x})]$$$$</p>
<p>其中 $$\hat{x}$$ 是我们要找的状态估计，$$x$$ 是真实状态。</p>
<p>当我们同时考虑过程噪声和测量噪声时，卡尔曼增益 $$K$$ 的表达式可以被写成：</p>
<p>$$$$K &#x3D; PH^T(HPH^T + R)^{-1}$$$$</p>
<p>这个公式正是将两种噪声整合到同一个优化问题的结果。其中 $$P$$ 是状态协方差矩阵，它表示状态估计的不确定性；$$H$$ 是观测矩阵；$$R$$ 是测量噪声协方差矩阵。这个增益作为一个加权因子，同时考虑了状态不确定性和测量噪声。</p>
<p>从这个增益表达式中，我们可以看出：</p>
<ol>
<li>当测量噪声较大时（$$R$$ 较大），$$K$$ 会较小，系统会更多地依赖模型预测</li>
<li>当状态不确定性较大时（$$P$$ 较大），$$K$$ 会较大，系统会更多地依赖测量值</li>
</ol>
<p>卡尔曼滤波的状态估计方程也很直观。如果我们没有测量值，状态估计就会仅根据系统模型传播。引入测量后，我们添加一个”校正项”，它代表了根据测量需要对传播状态进行的修正量。</p>
<p>关于自动估计噪声协方差的研究，有几种方法：</p>
<p>一种实用的方法是自协方差最小二乘(Autocovariance Least-Squares, ALS)技术，它使用常规操作数据的时滞自协方差来估计协方差矩阵。 另外，Field Kalman Filter (FKF)算法也被提出用于同时估计状态、参数和噪声协方差。</p>
<p>这些方法的核心是将两种噪声的估计整合到同一个优化框架中，通过迭代求解或者批处理方法来获得最优解。</p>
<p>在实际应用中，算法选择应基于具体问题特性、计算资源限制和精度要求。。</p>
<h1 id="ROS中的人体骨架定位、跟踪与识别"><a href="#ROS中的人体骨架定位、跟踪与识别" class="headerlink" title="ROS中的人体骨架定位、跟踪与识别"></a>ROS中的人体骨架定位、跟踪与识别</h1><h2 id="一、人体骨架定位"><a href="#一、人体骨架定位" class="headerlink" title="一、人体骨架定位"></a>一、人体骨架定位</h2><h3 id="1-1-基本介绍-1"><a href="#1-1-基本介绍-1" class="headerlink" title="1.1 基本介绍"></a>1.1 基本介绍</h3><p>人体骨架定位是指从图像或视频中识别并提取人体关键关节点的位置和连接关系，构建出人体姿态的骨架模型。在ROS中，这通常依赖于深度相机或RGB-D传感器，结合计算机视觉算法实现。</p>
<p><strong>基本数学变量</strong>：</p>
<ul>
<li>$$J &#x3D; {j_1, j_2, …, j_n}$$：人体关键关节点集合，通常包括头部、肩部、肘部、手腕、髋部、膝盖和脚踝等</li>
<li>$$P_i &#x3D; (x_i, y_i, z_i)$$：第i个关节点的三维坐标</li>
<li>$$C_{i,j}$$：关节点i和j之间的连接关系，通常表示为骨骼连接</li>
<li>$$S &#x3D; {J, C}$$：完整的骨架模型</li>
<li>$$I$$：输入图像或点云数据</li>
<li>$$\theta$$：模型参数，如深度学习网络的权重</li>
</ul>
<h3 id="1-2-基本思路-1"><a href="#1-2-基本思路-1" class="headerlink" title="1.2 基本思路"></a>1.2 基本思路</h3><p>人体骨架定位可以看作是一位精确的”人体画家”，通过观察人的外形，勾勒出内部骨架结构。</p>
<p><strong>骨架绘制过程</strong>：</p>
<ol>
<li><p><strong>观察阶段</strong>：画家获取人体图像</p>
<ul>
<li>“我看到一个人站在那里，我需要描绘出他的骨架结构”</li>
</ul>
</li>
<li><p><strong>标记关键点</strong>：画家确定关键关节位置</p>
<ul>
<li>“我先确定头部、肩膀、肘部等关键位置”</li>
<li>这一步通常使用深度学习模型来完成</li>
</ul>
</li>
<li><p><strong>连接骨骼</strong>：画家将关键点连接起来</p>
<ul>
<li>“我将头部与颈部连接，肩部与肘部连接，构成完整骨架”</li>
</ul>
</li>
</ol>
<p><strong>核心公式</strong>：</p>
<p>对于基于深度学习的方法，如OpenPose，核心是热图预测：</p>
<ul>
<li>关节点热图预测：$$H_j &#x3D; f_{\theta}(I)$$，其中$$H_j$$是第j个关节点的热图，$$f_{\theta}$$是参数为$$\theta$$的网络</li>
<li>关节点位置提取：$$P_j &#x3D; \arg\max_{(x,y)} H_j(x,y)$$</li>
<li>骨骼连接通过部分亲和场(PAF)预测：$$L_{i,j} &#x3D; g_{\theta}(I)$$，表示关节点i和j之间的连接向量场</li>
</ul>
<h3 id="1-3-数学推导-1"><a href="#1-3-数学推导-1" class="headerlink" title="1.3 数学推导"></a>1.3 数学推导</h3><p>基于深度学习的人体骨架定位算法的数学推导：</p>
<ol>
<li><p><strong>多人姿态估计问题定义</strong>：</p>
<ul>
<li>输入：图像$$I$$</li>
<li>输出：多个人体骨架$$S &#x3D; {S^1, S^2, …, S^k}$$，其中$$S^i &#x3D; {J^i, C^i}$$</li>
</ul>
</li>
<li><p><strong>两阶段方法（如OpenPose）</strong>：</p>
<ul>
<li><p>第一阶段：检测所有可能的关节点位置</p>
<ul>
<li>对每种关节类型$$j$$，预测热图$$H_j$$</li>
<li>损失函数：$$L_{joint} &#x3D; \sum_{j&#x3D;1}^n \sum_{p} ||H_j(p) - H_j^*(p)||_2^2$$</li>
<li>其中$$H_j^*$$是真实热图标注，$$p$$遍历所有像素位置</li>
</ul>
</li>
<li><p>第二阶段：确定关节点之间的连接关系</p>
<ul>
<li>预测部分亲和场(PAF)：$$L_{i,j}$$，表示从关节$$i$$到关节$$j$$的向量场</li>
<li>损失函数：$$L_{paf} &#x3D; \sum_{(i,j) \in C} \sum_{p} ||L_{i,j}(p) - L_{i,j}^*(p)||_2^2$$</li>
<li>其中$$L_{i,j}^*$$是真实PAF标注</li>
</ul>
</li>
<li><p>总损失函数：$$L_{total} &#x3D; L_{joint} + L_{paf}$$</p>
</li>
</ul>
</li>
<li><p><strong>匹配过程</strong>：</p>
<ul>
<li>对于每对相连的关节类型$$(i,j)$$，考虑所有候选关节点</li>
<li>对于候选点对$$(j_i^a, j_j^b)$$，计算连接分数：<br>$$E_{i,j}^{a,b} &#x3D; \int_{u&#x3D;0}^1 L_{i,j}(p(u)) \cdot \frac{j_j^b - j_i^a}{||j_j^b - j_i^a||_2} du$$<br>其中$$p(u) &#x3D; (1-u)j_i^a + u j_j^b$$，$$u \in [0,1]$$</li>
<li>使用最大权二分图匹配算法找到最优的关节点关联</li>
</ul>
</li>
<li><p><strong>骨架组装</strong>：</p>
<ul>
<li>从高置信度的连接开始，逐步组装完整骨架</li>
<li>解决连接冲突，得到最终的人体骨架集合</li>
</ul>
</li>
</ol>
<h3 id="1-4-ROS源码实现-1"><a href="#1-4-ROS源码实现-1" class="headerlink" title="1.4 ROS源码实现"></a>1.4 ROS源码实现</h3><p>以下是在ROS中实现基于OpenPose的人体骨架定位的核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sensor_msgs/Image.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv_bridge/cv_bridge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openpose_ros_msgs/PersonArray.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openpose/pose/poseExtractorCaffe.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openpose/pose/poseParameters.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenPoseROS</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ros::NodeHandle nh_;</span><br><span class="line">  ros::Subscriber image_sub_;</span><br><span class="line">  ros::Publisher skeleton_pub_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// OpenPose参数</span></span><br><span class="line">  op::Wrapper opWrapper_;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">OpenPoseROS</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化OpenPose</span></span><br><span class="line">    op::PoseModel poseModel = op::PoseModel::BODY_25;</span><br><span class="line">    op::WrapperStructPose wrapperStructPose;</span><br><span class="line">    wrapperStructPose.poseModel = poseModel;</span><br><span class="line">    wrapperStructPose.netInputSize = op::<span class="built_in">Point</span>&lt;<span class="type">int</span>&gt;(<span class="number">368</span>, <span class="number">368</span>);</span><br><span class="line">    wrapperStructPose.outputSize = op::<span class="built_in">Point</span>&lt;<span class="type">int</span>&gt;(<span class="number">1280</span>, <span class="number">720</span>);</span><br><span class="line">    wrapperStructPose.keypointScaleMode = op::ScaleMode::InputResolution;</span><br><span class="line">    wrapperStructPose.gpuNumber = <span class="number">0</span>;</span><br><span class="line">    wrapperStructPose.gpuNumberStart = <span class="number">0</span>;</span><br><span class="line">    wrapperStructPose.scalesNumber = <span class="number">1</span>;</span><br><span class="line">    wrapperStructPose.scaleGap = <span class="number">0.3f</span>;</span><br><span class="line">    </span><br><span class="line">    opWrapper_.<span class="built_in">configure</span>(wrapperStructPose);</span><br><span class="line">    opWrapper_.<span class="built_in">start</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 订阅图像并发布骨架数据</span></span><br><span class="line">    image_sub_ = nh_.<span class="built_in">subscribe</span>(<span class="string">&quot;/camera/rgb/image_raw&quot;</span>, <span class="number">1</span>, </span><br><span class="line">                               &amp;OpenPoseROS::imageCallback, <span class="keyword">this</span>);</span><br><span class="line">    skeleton_pub_ = nh_.<span class="built_in">advertise</span>&lt;openpose_ros_msgs::PersonArray&gt;(<span class="string">&quot;/openpose/poses&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">imageCallback</span><span class="params">(<span class="type">const</span> sensor_msgs::Image::ConstPtr&amp; msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 转换ROS图像到OpenCV格式</span></span><br><span class="line">      cv_bridge::CvImageConstPtr cv_ptr = cv_bridge::<span class="built_in">toCvShare</span>(msg, <span class="string">&quot;bgr8&quot;</span>);</span><br><span class="line">      cv::Mat inputImage = cv_ptr-&gt;image.<span class="built_in">clone</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 准备OpenPose输入数据</span></span><br><span class="line">      <span class="keyword">auto</span> datumsPtr = std::make_shared&lt;std::vector&lt;op::Datum&gt;&gt;();</span><br><span class="line">      datumsPtr-&gt;<span class="built_in">emplace_back</span>();</span><br><span class="line">      <span class="keyword">auto</span>&amp; datum = datumsPtr-&gt;<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">      datum.cvInputData = inputImage;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 处理图像</span></span><br><span class="line">      opWrapper_.<span class="built_in">emplaceAndPop</span>(datumsPtr);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (datumsPtr != <span class="literal">nullptr</span> &amp;&amp; !datumsPtr-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; poseKeypoints = datumsPtr-&gt;<span class="built_in">at</span>(<span class="number">0</span>).poseKeypoints;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建消息</span></span><br><span class="line">        openpose_ros_msgs::PersonArray personArray;</span><br><span class="line">        personArray.header = msg-&gt;header;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 提取每个人的骨架</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> personIdx = <span class="number">0</span>; personIdx &lt; poseKeypoints.<span class="built_in">getSize</span>(<span class="number">0</span>); personIdx++) &#123;</span><br><span class="line">          openpose_ros_msgs::Person person;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 提取关键点</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">size_t</span> keypointIdx = <span class="number">0</span>; keypointIdx &lt; poseKeypoints.<span class="built_in">getSize</span>(<span class="number">1</span>); keypointIdx++) &#123;</span><br><span class="line">            openpose_ros_msgs::KeyPoint keypoint;</span><br><span class="line">            keypoint.position.x = poseKeypoints[&#123;personIdx, keypointIdx, <span class="number">0</span>&#125;];</span><br><span class="line">            keypoint.position.y = poseKeypoints[&#123;personIdx, keypointIdx, <span class="number">1</span>&#125;];</span><br><span class="line">            keypoint.confidence = poseKeypoints[&#123;personIdx, keypointIdx, <span class="number">2</span>&#125;];</span><br><span class="line">            person.keypoints.<span class="built_in">push_back</span>(keypoint);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          personArray.persons.<span class="built_in">push_back</span>(person);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发布结果</span></span><br><span class="line">        skeleton_pub_.<span class="built_in">publish</span>(personArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">      <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Error processing image: %s&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;openpose_ros_node&quot;</span>);</span><br><span class="line">  OpenPoseROS openPoseROS;</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-3D骨架重建"><a href="#1-5-3D骨架重建" class="headerlink" title="1.5 3D骨架重建"></a>1.5 3D骨架重建</h3><p>对于ROS中的3D人体骨架定位，除了2D方法外，还有两种主要的3D重建方法：</p>
<p><strong>基于深度相机的直接3D重建</strong>：</p>
<ul>
<li>使用RGB-D摄像头(如Kinect、RealSense)获取深度信息</li>
<li>将2D关键点与深度图对应，直接获取3D坐标</li>
<li>优势：实现简单，速度快</li>
<li>局限性：依赖于深度相机的测量精度和范围</li>
</ul>
<p><strong>基于多视角的3D重建</strong>：</p>
<ul>
<li>使用多个相机从不同角度观察同一场景</li>
<li>通过三角测量原理重建3D骨架</li>
<li>优势：精度高，不受单一视角遮挡影响</li>
<li>局限性：需要多个相机和精确的相机标定</li>
</ul>
<h2 id="二、人体跟踪"><a href="#二、人体跟踪" class="headerlink" title="二、人体跟踪"></a>二、人体跟踪</h2><h3 id="2-1-基本介绍-1"><a href="#2-1-基本介绍-1" class="headerlink" title="2.1 基本介绍"></a>2.1 基本介绍</h3><p>人体跟踪是指在连续的视频帧或传感器数据流中持续定位并识别人体目标，解决帧间身份关联问题。在ROS中，人体跟踪系统通常结合检测、特征提取和运动预测等模块。</p>
<p><strong>基本数学变量</strong>：</p>
<ul>
<li>$$T &#x3D; {t_1, t_2, …, t_n}$$：跟踪目标集合</li>
<li>$$t_i &#x3D; {id_i, s_i, v_i, a_i}$$：第i个跟踪目标，包括唯一ID、骨架状态、速度和表观特征</li>
<li>$$D &#x3D; {d_1, d_2, …, d_m}$$：当前帧检测到的人体骨架集合</li>
<li>$$C_{i,j}$$：跟踪目标$$t_i$$与检测结果$$d_j$$之间的关联代价</li>
<li>$$A$$：关联矩阵，$$A_{i,j}&#x3D;1$$表示$$t_i$$与$$d_j$$关联</li>
<li>$$M_t$$：运动模型，预测目标的下一个状态</li>
<li>$$\Sigma$$：状态协方差矩阵，表示预测的不确定性</li>
</ul>
<h3 id="2-2-基本思路-1"><a href="#2-2-基本思路-1" class="headerlink" title="2.2 基本思路"></a>2.2 基本思路</h3><p>人体跟踪可以比作一群”眼明手快的侦探”，负责在人群中持续追踪每个人的行动轨迹。</p>
<p><strong>跟踪侦探的工作过程</strong>：</p>
<ol>
<li><p><strong>识别阶段</strong>：侦探观察场景，发现所有人体</p>
<ul>
<li>“我看到场景中有5个人，分别站在不同位置”</li>
</ul>
</li>
<li><p><strong>关联阶段</strong>：侦探将当前观察与之前记忆中的人物匹配</p>
<ul>
<li>“红衣服的那位应该是我之前标记为ID-3的人，因为位置接近，而且穿着相同”</li>
<li>这一步使用匈牙利算法等解决数据关联问题</li>
</ul>
</li>
<li><p><strong>预测阶段</strong>：侦探预测各个人物下一步可能的位置</p>
<ul>
<li>“根据ID-3的移动方向和速度，我预测他下一秒会出现在门口附近”</li>
<li>这通常使用卡尔曼滤波等算法实现</li>
</ul>
</li>
</ol>
<p><strong>核心公式</strong>：</p>
<p>数据关联代价矩阵计算：<br>$$C_{i,j} &#x3D; w_p \cdot d_{pos}(t_i, d_j) + w_a \cdot d_{app}(t_i, d_j) + w_s \cdot d_{shape}(t_i, d_j)$$</p>
<p>其中$$d_{pos}$$是位置距离，$$d_{app}$$是表观特征距离，$$d_{shape}$$是形状差异，$$w_p$$、$$w_a$$、$$w_s$$是权重系数。</p>
<p>匈牙利算法求解最优关联：<br>$$A^* &#x3D; \arg\min_{A} \sum_{i,j} C_{i,j} \cdot A_{i,j}$$</p>
<p>状态预测（使用卡尔曼滤波）：<br>$$\hat{s}<em>{t|t-1} &#x3D; M_t \cdot \hat{s}</em>{t-1|t-1}$$<br>$$P_{t|t-1} &#x3D; M_t \cdot P_{t-1|t-1} \cdot M_t^T + Q_t$$</p>
<h3 id="2-3-数学推导-1"><a href="#2-3-数学推导-1" class="headerlink" title="2.3 数学推导"></a>2.3 数学推导</h3><p>人体跟踪的数学推导主要围绕目标关联和状态估计两个方面：</p>
<ol>
<li><p><strong>多目标跟踪问题定义</strong>：</p>
<ul>
<li>给定时间序列$$t&#x3D;1,…,T$$，在每个时刻观测到的检测集合$$D^t &#x3D; {d_1^t, d_2^t, …, d_{m_t}^t}$$</li>
<li>目标是估计轨迹集合$$\Gamma &#x3D; {\gamma_1, \gamma_2, …, \gamma_k}$$，其中每条轨迹$$\gamma_i &#x3D; {d_{i}^{t_i^{start}}, …, d_{i}^{t_i^{end}}}$$</li>
</ul>
</li>
<li><p><strong>目标状态表示与预测</strong>：</p>
<ul>
<li>使用卡尔曼滤波对每个跟踪目标建模</li>
<li>状态向量：$$x_t &#x3D; [p_x, p_y, p_z, v_x, v_y, v_z]^T$$，表示位置和速度</li>
<li>状态转移方程：$$x_t &#x3D; F x_{t-1} + w_{t-1}$$，其中$$F$$是状态转移矩阵，$$w$$是过程噪声</li>
<li>观测方程：$$z_t &#x3D; H x_t + v_t$$，其中$$H$$是观测矩阵，$$v$$是观测噪声</li>
<li>预测步骤：<ul>
<li>状态预测：$$\hat{x}<em>{t|t-1} &#x3D; F \hat{x}</em>{t-1|t-1}$$</li>
<li>协方差预测：$$P_{t|t-1} &#x3D; F P_{t-1|t-1} F^T + Q$$</li>
</ul>
</li>
<li>更新步骤：<ul>
<li>卡尔曼增益：$$K_t &#x3D; P_{t|t-1} H^T (H P_{t|t-1} H^T + R)^{-1}$$</li>
<li>状态更新：$$\hat{x}<em>{t|t} &#x3D; \hat{x}</em>{t|t-1} + K_t (z_t - H \hat{x}_{t|t-1})$$</li>
<li>协方差更新：$$P_{t|t} &#x3D; (I - K_t H) P_{t|t-1}$$</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据关联</strong>：</p>
<ul>
<li>对于每对跟踪目标$$t_i$$和检测结果$$d_j$$，计算关联代价$$C_{i,j}$$</li>
<li>位置代价：$$d_{pos}(t_i, d_j) &#x3D; ||p_i - p_j||_2$$</li>
<li>表观代价：$$d_{app}(t_i, d_j) &#x3D; 1 - \frac{f_i \cdot f_j}{||f_i||_2 \cdot ||f_j||_2}$$，其中$$f$$是表观特征向量</li>
<li>构建代价矩阵$$C$$，并使用匈牙利算法求解最优匹配$$A^*$$</li>
<li>匹配质量阈值：只接受代价小于阈值$$\tau$$的匹配，即$$C_{i,j} &lt; \tau$$</li>
</ul>
</li>
<li><p><strong>轨迹管理</strong>：</p>
<ul>
<li>新轨迹初始化：未匹配的检测结果初始化为新轨迹</li>
<li>轨迹确认：新轨迹在连续$$N_{conf}$$帧中匹配成功后确认</li>
<li>轨迹终止：轨迹在连续$$N_{lost}$$帧中未匹配后终止</li>
<li>轨迹平滑：对确认的轨迹应用滤波平滑处理</li>
</ul>
</li>
</ol>
<h3 id="2-4-ROS源码实现-1"><a href="#2-4-ROS源码实现-1" class="headerlink" title="2.4 ROS源码实现"></a>2.4 ROS源码实现</h3><p>以下是在ROS中实现基于卡尔曼滤波的人体跟踪系统的核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openpose_ros_msgs/PersonArray.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;visualization_msgs/MarkerArray.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanTracker</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Track</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    Eigen::VectorXd state;  <span class="comment">// [x, y, z, vx, vy, vz]</span></span><br><span class="line">    Eigen::MatrixXd covariance;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; appearance_feat;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> time_since_update;</span><br><span class="line">    <span class="type">bool</span> is_confirmed;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  std::vector&lt;Track&gt; tracks_;</span><br><span class="line">  <span class="type">int</span> next_id_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 卡尔曼滤波参数</span></span><br><span class="line">  Eigen::MatrixXd F_;  <span class="comment">// 状态转移矩阵</span></span><br><span class="line">  Eigen::MatrixXd H_;  <span class="comment">// 观测矩阵</span></span><br><span class="line">  Eigen::MatrixXd Q_;  <span class="comment">// 过程噪声协方差</span></span><br><span class="line">  Eigen::MatrixXd R_;  <span class="comment">// 观测噪声协方差</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 跟踪参数</span></span><br><span class="line">  <span class="type">float</span> max_dist_threshold_;</span><br><span class="line">  <span class="type">int</span> confirm_threshold_;</span><br><span class="line">  <span class="type">int</span> delete_threshold_;</span><br><span class="line">  </span><br><span class="line">  ros::NodeHandle nh_;</span><br><span class="line">  ros::Subscriber skeleton_sub_;</span><br><span class="line">  ros::Publisher track_pub_;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">HumanTracker</span>() : <span class="built_in">next_id_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化卡尔曼滤波参数</span></span><br><span class="line">    <span class="built_in">initKalmanParameters</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化跟踪参数</span></span><br><span class="line">    nh_.<span class="built_in">param</span>(<span class="string">&quot;max_dist_threshold&quot;</span>, max_dist_threshold_, <span class="number">1.0f</span>);</span><br><span class="line">    nh_.<span class="built_in">param</span>(<span class="string">&quot;confirm_threshold&quot;</span>, confirm_threshold_, <span class="number">3</span>);</span><br><span class="line">    nh_.<span class="built_in">param</span>(<span class="string">&quot;delete_threshold&quot;</span>, delete_threshold_, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 订阅骨架数据并发布跟踪结果</span></span><br><span class="line">    skeleton_sub_ = nh_.<span class="built_in">subscribe</span>(<span class="string">&quot;/openpose/poses&quot;</span>, <span class="number">1</span>, </span><br><span class="line">                                 &amp;HumanTracker::skeletonCallback, <span class="keyword">this</span>);</span><br><span class="line">    track_pub_ = nh_.<span class="built_in">advertise</span>&lt;visualization_msgs::MarkerArray&gt;(<span class="string">&quot;/human_tracks&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">initKalmanParameters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 状态：[x, y, z, vx, vy, vz]</span></span><br><span class="line">    <span class="type">int</span> state_dim = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> meas_dim = <span class="number">3</span>;  <span class="comment">// 测量：[x, y, z]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态转移矩阵 (考虑匀速运动模型)</span></span><br><span class="line">    F_ = Eigen::MatrixXd::<span class="built_in">Identity</span>(state_dim, state_dim);</span><br><span class="line">    <span class="type">double</span> dt = <span class="number">0.1</span>;  <span class="comment">// 时间步长</span></span><br><span class="line">    <span class="built_in">F_</span>(<span class="number">0</span>, <span class="number">3</span>) = dt;</span><br><span class="line">    <span class="built_in">F_</span>(<span class="number">1</span>, <span class="number">4</span>) = dt;</span><br><span class="line">    <span class="built_in">F_</span>(<span class="number">2</span>, <span class="number">5</span>) = dt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 观测矩阵</span></span><br><span class="line">    H_ = Eigen::MatrixXd::<span class="built_in">Zero</span>(meas_dim, state_dim);</span><br><span class="line">    <span class="built_in">H_</span>(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">1.0</span>;</span><br><span class="line">    <span class="built_in">H_</span>(<span class="number">1</span>, <span class="number">1</span>) = <span class="number">1.0</span>;</span><br><span class="line">    <span class="built_in">H_</span>(<span class="number">2</span>, <span class="number">2</span>) = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 过程噪声</span></span><br><span class="line">    Q_ = Eigen::MatrixXd::<span class="built_in">Identity</span>(state_dim, state_dim) * <span class="number">0.1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 观测噪声</span></span><br><span class="line">    R_ = Eigen::MatrixXd::<span class="built_in">Identity</span>(meas_dim, meas_dim) * <span class="number">0.2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">skeletonCallback</span><span class="params">(<span class="type">const</span> openpose_ros_msgs::PersonArray::ConstPtr&amp; msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提取当前帧的检测结果</span></span><br><span class="line">    std::vector&lt;Eigen::VectorXd&gt; detections;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">float</span>&gt;&gt; features;</span><br><span class="line">    <span class="built_in">extractDetections</span>(msg, detections, features);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预测所有轨迹的新状态</span></span><br><span class="line">    <span class="built_in">predictTracks</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算代价矩阵</span></span><br><span class="line">    Eigen::MatrixXd cost_matrix = <span class="built_in">computeCostMatrix</span>(detections, features);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用匈牙利算法进行数据关联</span></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; matches;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; unmatched_tracks;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; unmatched_detections;</span><br><span class="line">    <span class="built_in">associateDetectionsToTracks</span>(cost_matrix, matches, unmatched_tracks, unmatched_detections);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新匹配的轨迹</span></span><br><span class="line">    <span class="built_in">updateMatchedTracks</span>(matches, detections, features);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理未匹配的检测，创建新轨迹</span></span><br><span class="line">    <span class="built_in">createNewTracks</span>(unmatched_detections, detections, features);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新未匹配的轨迹</span></span><br><span class="line">    <span class="built_in">updateUnmatchedTracks</span>(unmatched_tracks);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除过旧的轨迹</span></span><br><span class="line">    <span class="built_in">deleteLostTracks</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发布跟踪结果</span></span><br><span class="line">    <span class="built_in">publishTracks</span>(msg-&gt;header);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">extractDetections</span><span class="params">(<span class="type">const</span> openpose_ros_msgs::PersonArray::ConstPtr&amp; msg,</span></span></span><br><span class="line"><span class="params"><span class="function">                        std::vector&lt;Eigen::VectorXd&gt;&amp; detections,</span></span></span><br><span class="line"><span class="params"><span class="function">                        std::vector&lt;std::vector&lt;<span class="type">float</span>&gt;&gt;&amp; features)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; person : msg-&gt;persons) &#123;</span><br><span class="line">      <span class="comment">// 提取人体位置（使用骨架中心或特定关节点）</span></span><br><span class="line">      <span class="function">Eigen::VectorXd <span class="title">pos</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">      <span class="comment">// 简化：使用骨盆(关节点8)作为人体位置</span></span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; pelvis = person.keypoints[<span class="number">8</span>];</span><br><span class="line">      pos &lt;&lt; pelvis.position.x, pelvis.position.y, <span class="number">0.0</span>;  <span class="comment">// 假设z=0</span></span><br><span class="line">      </span><br><span class="line">      detections.<span class="built_in">push_back</span>(pos);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 提取表观特征（简化示例）</span></span><br><span class="line">      std::vector&lt;<span class="type">float</span>&gt; feat;</span><br><span class="line">      <span class="comment">// 这里可以提取骨架形状、颜色直方图等特征</span></span><br><span class="line">      <span class="comment">// 简化：使用关键点相对位置作为特征</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; kp : person.keypoints) &#123;</span><br><span class="line">        feat.<span class="built_in">push_back</span>(kp.position.x - pelvis.position.x);</span><br><span class="line">        feat.<span class="built_in">push_back</span>(kp.position.y - pelvis.position.y);</span><br><span class="line">      &#125;</span><br><span class="line">      features.<span class="built_in">push_back</span>(feat);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">predictTracks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; track : tracks_) &#123;</span><br><span class="line">      <span class="comment">// 预测步骤</span></span><br><span class="line">      track.state = F_ * track.state;</span><br><span class="line">      track.covariance = F_ * track.covariance * F_.<span class="built_in">transpose</span>() + Q_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">Eigen::MatrixXd <span class="title">computeCostMatrix</span><span class="params">(<span class="type">const</span> std::vector&lt;Eigen::VectorXd&gt;&amp; detections,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> std::vector&lt;std::vector&lt;<span class="type">float</span>&gt;&gt;&amp; features)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n_tracks = tracks_.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n_detections = detections.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    Eigen::MatrixXd cost_matrix = Eigen::MatrixXd::<span class="built_in">Constant</span>(n_tracks, n_detections, <span class="number">1000.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_tracks; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n_detections; j++) &#123;</span><br><span class="line">        <span class="comment">// 计算位置距离</span></span><br><span class="line">        Eigen::VectorXd pos_diff = detections[j] - tracks_[i].state.<span class="built_in">head</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">double</span> pos_dist = pos_diff.<span class="built_in">norm</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算特征距离（简化）</span></span><br><span class="line">        <span class="type">double</span> feat_dist = <span class="number">0.0</span>;</span><br><span class="line">        <span class="comment">// 实际应用中应使用更复杂的特征匹配</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 组合距离</span></span><br><span class="line">        <span class="type">double</span> cost = <span class="number">0.7</span> * pos_dist + <span class="number">0.3</span> * feat_dist;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cost &lt; max_dist_threshold_) &#123;</span><br><span class="line">          <span class="built_in">cost_matrix</span>(i, j) = cost;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cost_matrix;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">associateDetectionsToTracks</span><span class="params">(<span class="type">const</span> Eigen::MatrixXd&amp; cost_matrix,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; matches,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::vector&lt;<span class="type">int</span>&gt;&amp; unmatched_tracks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::vector&lt;<span class="type">int</span>&gt;&amp; unmatched_detections)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用匈牙利算法求解最优匹配</span></span><br><span class="line">    <span class="comment">// 简化：这里使用贪心方法替代</span></span><br><span class="line">    <span class="type">int</span> n_tracks = cost_matrix.<span class="built_in">rows</span>();</span><br><span class="line">    <span class="type">int</span> n_detections = cost_matrix.<span class="built_in">cols</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">assigned_tracks</span><span class="params">(n_tracks, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">assigned_detections</span><span class="params">(n_detections, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 贪心分配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_tracks; i++) &#123;</span><br><span class="line">      <span class="type">int</span> best_detection = <span class="number">-1</span>;</span><br><span class="line">      <span class="type">double</span> min_cost = max_dist_threshold_;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n_detections; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!assigned_detections[j] &amp;&amp; <span class="built_in">cost_matrix</span>(i, j) &lt; min_cost) &#123;</span><br><span class="line">          min_cost = <span class="built_in">cost_matrix</span>(i, j);</span><br><span class="line">          best_detection = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (best_detection &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        matches.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(i, best_detection));</span><br><span class="line">        assigned_tracks[i] = <span class="literal">true</span>;</span><br><span class="line">        assigned_detections[best_detection] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收集未匹配的轨迹和检测</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_tracks; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!assigned_tracks[i]) &#123;</span><br><span class="line">        unmatched_tracks.<span class="built_in">push_back</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n_detections; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!assigned_detections[j]) &#123;</span><br><span class="line">        unmatched_detections.<span class="built_in">push_back</span>(j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">updateMatchedTracks</span><span class="params">(<span class="type">const</span> std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; matches,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> std::vector&lt;Eigen::VectorXd&gt;&amp; detections,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> std::vector&lt;std::vector&lt;<span class="type">float</span>&gt;&gt;&amp; features)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; match : matches) &#123;</span><br><span class="line">      <span class="type">int</span> track_idx = match.first;</span><br><span class="line">      <span class="type">int</span> det_idx = match.second;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 提取测量值</span></span><br><span class="line">      Eigen::VectorXd measurement = detections[det_idx];</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 卡尔曼滤波更新</span></span><br><span class="line">      Eigen::MatrixXd K = tracks_[track_idx].covariance * H_.<span class="built_in">transpose</span>() * </span><br><span class="line">                          (H_ * tracks_[track_idx].covariance * H_.<span class="built_in">transpose</span>() + R_).<span class="built_in">inverse</span>();</span><br><span class="line">      </span><br><span class="line">      tracks_[track_idx].state = tracks_[track_idx].state + </span><br><span class="line">                                K * (measurement - H_ * tracks_[track_idx].state);</span><br><span class="line">      </span><br><span class="line">      tracks_[track_idx].covariance = (Eigen::MatrixXd::<span class="built_in">Identity</span>(<span class="number">6</span>, <span class="number">6</span>) - K * H_) * </span><br><span class="line">                                      tracks_[track_idx].covariance;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 更新表观特征（简化，实际应该使用更平滑的更新）</span></span><br><span class="line">      tracks_[track_idx].appearance_feat = features[det_idx];</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 更新跟踪状态</span></span><br><span class="line">      tracks_[track_idx].age++;</span><br><span class="line">      tracks_[track_idx].time_since_update = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 确认轨迹</span></span><br><span class="line">      <span class="keyword">if</span> (!tracks_[track_idx].is_confirmed &amp;&amp; tracks_[track_idx].age &gt;= confirm_threshold_) &#123;</span><br><span class="line">        tracks_[track_idx].is_confirmed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">updateUnmatchedTracks</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; unmatched_tracks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> idx : unmatched_tracks) &#123;</span><br><span class="line">      tracks_[idx].time_since_update++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">createNewTracks</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; unmatched_detections,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> std::vector&lt;Eigen::VectorXd&gt;&amp; detections,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> std::vector&lt;std::vector&lt;<span class="type">float</span>&gt;&gt;&amp; features)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> idx : unmatched_detections) &#123;</span><br><span class="line">      Track new_track;</span><br><span class="line">      new_track.id = next_id_++;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 初始化状态向量 [x, y, z, vx, vy, vz]</span></span><br><span class="line">      new_track.state = Eigen::<span class="built_in">VectorXd</span>(<span class="number">6</span>);</span><br><span class="line">      new_track.state &lt;&lt; detections[idx](<span class="number">0</span>), detections[idx](<span class="number">1</span>), detections[idx](<span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 初始化协方差矩阵</span></span><br><span class="line">      new_track.covariance = Eigen::MatrixXd::<span class="built_in">Identity</span>(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">      new_track.covariance.<span class="built_in">diagonal</span>() &lt;&lt; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">10.0</span>, <span class="number">10.0</span>, <span class="number">10.0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 初始化表观特征</span></span><br><span class="line">      new_track.appearance_feat = features[idx];</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 初始化跟踪状态</span></span><br><span class="line">      new_track.age = <span class="number">1</span>;</span><br><span class="line">      new_track.time_since_update = <span class="number">0</span>;</span><br><span class="line">      new_track.is_confirmed = <span class="literal">false</span>;</span><br><span class="line">      </span><br><span class="line">      tracks_.<span class="built_in">push_back</span>(new_track);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">deleteLostTracks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Track&gt; retained_tracks;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; track : tracks_) &#123;</span><br><span class="line">      <span class="comment">// 保留最近更新的或已确认的轨迹</span></span><br><span class="line">      <span class="keyword">if</span> (track.time_since_update &lt; delete_threshold_ || </span><br><span class="line">          (track.is_confirmed &amp;&amp; track.time_since_update &lt; <span class="number">2</span>*delete_threshold_)) &#123;</span><br><span class="line">        retained_tracks.<span class="built_in">push_back</span>(track);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tracks_ = retained_tracks;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">publishTracks</span><span class="params">(<span class="type">const</span> std_msgs::Header&amp; header)</span> </span>&#123;</span><br><span class="line">    visualization_msgs::MarkerArray marker_array;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; track : tracks_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!track.is_confirmed) <span class="keyword">continue</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 创建人体位置标记</span></span><br><span class="line">      visualization_msgs::Marker marker;</span><br><span class="line">      marker.header = header;</span><br><span class="line">      marker.ns = <span class="string">&quot;human_tracks&quot;</span>;</span><br><span class="line">      marker.id = track.id;</span><br><span class="line">      marker.type = visualization_msgs::Marker::CYLINDER;</span><br><span class="line">      marker.action = visualization_msgs::Marker::ADD;</span><br><span class="line">      </span><br><span class="line">      marker.pose.position.x = track.<span class="built_in">state</span>(<span class="number">0</span>);</span><br><span class="line">      marker.pose.position.y = track.<span class="built_in">state</span>(<span class="number">1</span>);</span><br><span class="line">      marker.pose.position.z = track.<span class="built_in">state</span>(<span class="number">2</span>) + <span class="number">0.8</span>;  <span class="comment">// 人体中心点上方</span></span><br><span class="line">      </span><br><span class="line">      marker.pose.orientation.w = <span class="number">1.0</span>;</span><br><span class="line">      marker.scale.x = <span class="number">0.4</span>;</span><br><span class="line">      marker.scale.y = <span class="number">0.4</span>;</span><br><span class="line">      marker.scale.z = <span class="number">1.6</span>;  <span class="comment">// 典型人体高度</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 不同ID使用不同颜色</span></span><br><span class="line">      <span class="type">int</span> hue = (track.id * <span class="number">40</span>) % <span class="number">360</span>;  <span class="comment">// HSV色彩空间的色调</span></span><br><span class="line">      <span class="type">float</span> r, g, b;</span><br><span class="line">      <span class="built_in">hsv2rgb</span>(hue, <span class="number">1.0</span>, <span class="number">1.0</span>, r, g, b);</span><br><span class="line">      </span><br><span class="line">      marker.color.r = r;</span><br><span class="line">      marker.color.g = g;</span><br><span class="line">      marker.color.b = b;</span><br><span class="line">      marker.color.a = <span class="number">0.7</span>;</span><br><span class="line">      </span><br><span class="line">      marker.lifetime = ros::<span class="built_in">Duration</span>(<span class="number">0.5</span>);</span><br><span class="line">      </span><br><span class="line">      marker_array.markers.<span class="built_in">push_back</span>(marker);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 添加ID文本标记</span></span><br><span class="line">      visualization_msgs::Marker text_marker = marker;</span><br><span class="line">      text_marker.id = track.id + <span class="number">1000</span>;  <span class="comment">// 避免ID冲突</span></span><br><span class="line">      text_marker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;</span><br><span class="line">      text_marker.pose.position.z += <span class="number">0.9</span>;  <span class="comment">// 文本位于人体上方</span></span><br><span class="line">      text_marker.scale.x = <span class="number">0.0</span>;</span><br><span class="line">      text_marker.scale.y = <span class="number">0.0</span>;</span><br><span class="line">      text_marker.scale.z = <span class="number">0.3</span>;  <span class="comment">// 文本大小</span></span><br><span class="line">      text_marker.color.r = <span class="number">1.0</span>;</span><br><span class="line">      text_marker.color.g = <span class="number">1.0</span>;</span><br><span class="line">      text_marker.color.b = <span class="number">1.0</span>;</span><br><span class="line">      text_marker.color.a = <span class="number">1.0</span>;</span><br><span class="line">      text_marker.text = <span class="string">&quot;ID: &quot;</span> + std::<span class="built_in">to_string</span>(track.id);</span><br><span class="line">      </span><br><span class="line">      marker_array.markers.<span class="built_in">push_back</span>(text_marker);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    track_pub_.<span class="built_in">publish</span>(marker_array);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// HSV转RGB辅助函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">hsv2rgb</span><span class="params">(<span class="type">float</span> h, <span class="type">float</span> s, <span class="type">float</span> v, <span class="type">float</span>&amp; r, <span class="type">float</span>&amp; g, <span class="type">float</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hi = <span class="built_in">int</span>(h / <span class="number">60</span>) % <span class="number">6</span>;</span><br><span class="line">    <span class="type">float</span> f = h / <span class="number">60</span> - hi;</span><br><span class="line">    <span class="type">float</span> p = v * (<span class="number">1</span> - s);</span><br><span class="line">    <span class="type">float</span> q = v * (<span class="number">1</span> - f * s);</span><br><span class="line">    <span class="type">float</span> t = v * (<span class="number">1</span> - (<span class="number">1</span> - f) * s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (hi) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: r = v; g = t; b = p; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: r = q; g = v; b = p; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: r = p; g = v; b = t; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: r = p; g = q; b = v; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>: r = t; g = p; b = v; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>: r = v; g = p; b = q; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;human_tracker_node&quot;</span>);</span><br><span class="line">  HumanTracker tracker;</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-多模态跟踪与状态估计"><a href="#2-5-多模态跟踪与状态估计" class="headerlink" title="2.5 多模态跟踪与状态估计"></a>2.5 多模态跟踪与状态估计</h3><p>在ROS中，人体跟踪可以结合多种传感器数据和预测模型，主要有两种高级扩展：</p>
<p><strong>多模态感知跟踪</strong>：</p>
<ul>
<li>融合RGB相机、深度相机、激光雷达和IMU等多种传感器数据</li>
<li>不同传感器数据通过传感器融合算法整合，提高定位精度和鲁棒性</li>
<li>优势：克服单一传感器的局限性，如光线变化、遮挡等</li>
<li>常用方法：协方差交叉校准(CI)、概率数据融合</li>
</ul>
<p><strong>自适应状态估计</strong>：</p>
<ul>
<li>使用更高级的状态估计方法，如交互多模型(IMM)滤波</li>
<li>根据人体运动特性自动切换不同运动模型（匀速模型、加速模型、转弯模型）</li>
<li>优势：更准确预测复杂人体运动，如突然停止、快速转弯</li>
<li>应用：拥挤场景中的人体跟踪、人机交互场景中的意图识别</li>
</ul>
<h2 id="三、RGB与人体骨架的人物ID识别"><a href="#三、RGB与人体骨架的人物ID识别" class="headerlink" title="三、RGB与人体骨架的人物ID识别"></a>三、RGB与人体骨架的人物ID识别</h2><h3 id="3-1-基本介绍-1"><a href="#3-1-基本介绍-1" class="headerlink" title="3.1 基本介绍"></a>3.1 基本介绍</h3><p>RGB与人体骨架的人物ID识别是指将图像中的人体与其骨架数据关联起来，并为每个人赋予唯一标识符，实现跨帧、跨相机的身份一致性追踪。这通常结合视觉特征与骨架特征进行多模态识别。</p>
<p><strong>基本数学变量</strong>：</p>
<ul>
<li>$$I$$：RGB图像</li>
<li>$$S &#x3D; {J, C}$$：骨架数据，包括关节点集合$$J$$和连接关系$$C$$</li>
<li>$$P &#x3D; {p_1, p_2, …, p_n}$$：检测到的人物集合</li>
<li>$$p_i &#x3D; (bb_i, s_i, f_i, id_i)$$：第i个人物，包括边界框、骨架、特征向量和ID</li>
<li>$$f_i^{rgb}$$：第i个人物的RGB特征向量</li>
<li>$$f_i^{skel}$$：第i个人物的骨架特征向量</li>
<li>$$f_i^{fused} &#x3D; g(f_i^{rgb}, f_i^{skel})$$：融合特征向量</li>
<li>$$D(f_i, f_j)$$：特征向量之间的距离度量</li>
<li>$$G &#x3D; {V, E}$$：人物关系图，节点表示人物，边表示相似度</li>
</ul>
<h3 id="3-2-基本思路-1"><a href="#3-2-基本思路-1" class="headerlink" title="3.2 基本思路"></a>3.2 基本思路</h3><p>RGB与骨架的人物ID识别可以比作一位”全能侦探”，同时观察人的外貌和行为特征来识别身份。</p>
<p><strong>全能侦探的识别过程</strong>：</p>
<ol>
<li><p><strong>多维特征提取</strong>：侦探同时记录人的外貌和动作特征</p>
<ul>
<li>“这个人穿蓝色上衣，黑色裤子，走路时左腿稍微跛行”</li>
<li>这一步分别提取RGB视觉特征和骨架姿态特征</li>
</ul>
</li>
<li><p><strong>特征融合</strong>：侦探将外貌和行为线索结合起来</p>
<ul>
<li>“结合他的外貌和走路姿势，我有90%的把握这是John”</li>
<li>使用特征融合算法将RGB和骨架特征整合成更强大的识别特征</li>
</ul>
</li>
<li><p><strong>身份匹配</strong>：侦探将当前观察与记忆中的人物比对</p>
<ul>
<li>“比对我记录的所有人物特征，这个人最可能是上周见过的ID-42”</li>
<li>使用相似度计算和Re-ID算法确定最可能的身份</li>
</ul>
</li>
</ol>
<p><strong>核心公式</strong>：</p>
<p>特征提取与融合：<br>$$f_i^{rgb} &#x3D; CNN(bb_i)$$<br>$$f_i^{skel} &#x3D; SkeletonNet(s_i)$$<br>$$f_i^{fused} &#x3D; \alpha \cdot f_i^{rgb} + (1-\alpha) \cdot f_i^{skel}$$</p>
<p>相似度计算：<br>$$sim(p_i, p_j) &#x3D; \exp(-\frac{D(f_i^{fused}, f_j^{fused})^2}{2\sigma^2})$$</p>
<p>ID分配（使用匹配或聚类）：<br>$$id_i &#x3D; \arg\max_j sim(p_i, p_j) \text{ if } sim(p_i, p_j) &gt; \tau$$</p>
<h3 id="3-3-数学推导-1"><a href="#3-3-数学推导-1" class="headerlink" title="3.3 数学推导"></a>3.3 数学推导</h3><p>RGB与骨架的人物ID识别的数学推导围绕特征提取、融合和匹配三个核心环节：</p>
<ol>
<li><p><strong>RGB特征提取</strong>：</p>
<ul>
<li>使用卷积神经网络提取视觉特征：<br>$$f^{rgb} &#x3D; CNN(I_{bb})$$，其中$$I_{bb}$$是人物边界框中的图像区域</li>
<li>常用模型如ResNet或MobileNet，获取全局或局部特征</li>
</ul>
</li>
<li><p><strong>骨架特征提取</strong>：</p>
<ul>
<li>基于骨架数据构建特征：<br>$$f^{skel} &#x3D; SkeletonNet(S)$$</li>
<li>特征可包括：<ul>
<li>骨架形状特征：各关节点的相对位置和夹角</li>
<li>时间动态特征：关节运动轨迹和速度模式</li>
<li>长度比例特征：各骨骼段长度比例（生物测量特征）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>特征融合策略</strong>：</p>
<ul>
<li>早期融合：将RGB和骨架数据直接连接为联合输入<br>$$f^{joint} &#x3D; NN([I_{bb}, S])$$</li>
<li>中期融合：分别提取特征后在特征层融合<br>$$f^{fused} &#x3D; g(f^{rgb}, f^{skel})$$<br>其中$$g$$可以是简单连接、加权求和或注意力机制</li>
<li>后期融合：单独计算两种模态的相似度，再合并<br>$$sim(p_i, p_j) &#x3D; \beta \cdot sim^{rgb}(p_i, p_j) + (1-\beta) \cdot sim^{skel}(p_i, p_j)$$</li>
</ul>
</li>
<li><p><strong>相似度计算与匹配</strong>：</p>
<ul>
<li>余弦相似度：$$sim(f_i, f_j) &#x3D; \frac{f_i \cdot f_j}{||f_i|| \cdot ||f_j||}$$</li>
<li>马氏距离：$$D_M(f_i, f_j) &#x3D; \sqrt{(f_i - f_j)^T \Sigma^{-1} (f_i - f_j)}$$</li>
<li>使用度量学习(Metric Learning)优化特征空间，使相同身份的特征更接近，不同身份的特征更远离：<br>$$L_{triplet} &#x3D; max(||f_a - f_p||_2^2 - ||f_a - f_n||_2^2 + \alpha, 0)$$<br>其中$$f_a$$是锚点特征，$$f_p$$是正样本特征，$$f_n$$是负样本特征，$$\alpha$$是边距</li>
</ul>
</li>
<li><p><strong>ID分配与跟踪</strong>：</p>
<ul>
<li>匈牙利算法(这也是算法竞赛的一个内容)求解最优ID分配：<br>$$A^* &#x3D; \arg\min_{A} \sum_{i,j} (1-sim(p_i, p_j)) \cdot A_{i,j}$$</li>
<li>使用图结构表示人物关系，并采用聚类算法对图进行划分：<br>$$G &#x3D; (V, E)$$，其中$$V$$是人物集合，$$E_{i,j} &#x3D; sim(p_i, p_j)$$</li>
<li>应用谱聚类或社区检测算法确定身份组</li>
</ul>
</li>
</ol>
<h3 id="3-4-ROS源码实现-1"><a href="#3-4-ROS源码实现-1" class="headerlink" title="3.4 ROS源码实现"></a>3.4 ROS源码实现</h3><p>以下是在ROS中实现RGB与骨架融合的人物ID识别系统的核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sensor_msgs/Image.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cv_bridge/cv_bridge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openpose_ros_msgs/PersonArray.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vision_msgs/Detection2DArray.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;message_filters/subscriber.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;message_filters/synchronizer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;message_filters/sync_policies/approximate_time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;torch/torch.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonReID</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">PersonDescriptor</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    cv::Rect bbox;</span><br><span class="line">    std::vector&lt;cv::Point2f&gt; skeleton;</span><br><span class="line">    torch::Tensor rgb_feat;</span><br><span class="line">    torch::Tensor skel_feat;</span><br><span class="line">    torch::Tensor fused_feat;</span><br><span class="line">    ros::Time last_seen;</span><br><span class="line">    <span class="type">int</span> match_count;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  std::vector&lt;PersonDescriptor&gt; person_database_;</span><br><span class="line">  <span class="type">int</span> next_id_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 模型和参数</span></span><br><span class="line">  torch::jit::script::Module rgb_model_;</span><br><span class="line">  torch::jit::script::Module skel_model_;</span><br><span class="line">  <span class="type">float</span> match_threshold_;</span><br><span class="line">  <span class="type">float</span> fusion_alpha_;  <span class="comment">// RGB特征权重</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ROS接口</span></span><br><span class="line">  ros::NodeHandle nh_;</span><br><span class="line">  <span class="keyword">typedef</span> message_filters::sync_policies::ApproximateTime</span><br><span class="line">    sensor_msgs::Image, </span><br><span class="line">    openpose_ros_msgs::PersonArray, </span><br><span class="line">    vision_msgs::Detection2DArray&gt; SyncPolicy;</span><br><span class="line">  </span><br><span class="line">  message_filters::Subscriber&lt;sensor_msgs::Image&gt; image_sub_;</span><br><span class="line">  message_filters::Subscriber&lt;openpose_ros_msgs::PersonArray&gt; skeleton_sub_;</span><br><span class="line">  message_filters::Subscriber&lt;vision_msgs::Detection2DArray&gt; detection_sub_;</span><br><span class="line">  </span><br><span class="line">  message_filters::Synchronizer&lt;SyncPolicy&gt; sync_;</span><br><span class="line">  </span><br><span class="line">  ros::Publisher reid_pub_;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PersonReID</span>() : <span class="built_in">next_id_</span>(<span class="number">0</span>), </span><br><span class="line">                <span class="built_in">sync_</span>(<span class="built_in">SyncPolicy</span>(<span class="number">10</span>), image_sub_, skeleton_sub_, detection_sub_) &#123;</span><br><span class="line">    <span class="comment">// 加载参数</span></span><br><span class="line">    std::string rgb_model_path, skel_model_path;</span><br><span class="line">    nh_.<span class="built_in">param</span>(<span class="string">&quot;rgb_model_path&quot;</span>, rgb_model_path, std::<span class="built_in">string</span>(<span class="string">&quot;rgb_reid_model.pt&quot;</span>));</span><br><span class="line">    nh_.<span class="built_in">param</span>(<span class="string">&quot;skel_model_path&quot;</span>, skel_model_path, std::<span class="built_in">string</span>(<span class="string">&quot;skel_reid_model.pt&quot;</span>));</span><br><span class="line">    nh_.<span class="built_in">param</span>(<span class="string">&quot;match_threshold&quot;</span>, match_threshold_, <span class="number">0.7f</span>);</span><br><span class="line">    nh_.<span class="built_in">param</span>(<span class="string">&quot;fusion_alpha&quot;</span>, fusion_alpha_, <span class="number">0.6f</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 加载预训练模型</span></span><br><span class="line">      rgb_model_ = torch::jit::<span class="built_in">load</span>(rgb_model_path);</span><br><span class="line">      skel_model_ = torch::jit::<span class="built_in">load</span>(skel_model_path);</span><br><span class="line">      </span><br><span class="line">      rgb_model_.<span class="built_in">eval</span>();</span><br><span class="line">      skel_model_.<span class="built_in">eval</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Successfully loaded ReID models&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> c10::Error&amp; e) &#123;</span><br><span class="line">      <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Error loading models: %s&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置ROS接口</span></span><br><span class="line">    image_sub_.<span class="built_in">subscribe</span>(nh_, <span class="string">&quot;/camera/rgb/image_raw&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    skeleton_sub_.<span class="built_in">subscribe</span>(nh_, <span class="string">&quot;/openpose/poses&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    detection_sub_.<span class="built_in">subscribe</span>(nh_, <span class="string">&quot;/person_detection&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    sync_.<span class="built_in">registerCallback</span>(boost::<span class="built_in">bind</span>(&amp;PersonReID::callback, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">    </span><br><span class="line">    reid_pub_ = nh_.<span class="built_in">advertise</span>&lt;vision_msgs::Detection2DArray&gt;(<span class="string">&quot;/person_reid&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(<span class="type">const</span> sensor_msgs::Image::ConstPtr&amp; img_msg,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> openpose_ros_msgs::PersonArray::ConstPtr&amp; skel_msg,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> vision_msgs::Detection2DArray::ConstPtr&amp; det_msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 转换ROS图像到OpenCV格式</span></span><br><span class="line">      cv_bridge::CvImageConstPtr cv_ptr = cv_bridge::<span class="built_in">toCvShare</span>(img_msg, <span class="string">&quot;bgr8&quot;</span>);</span><br><span class="line">      cv::Mat image = cv_ptr-&gt;image.<span class="built_in">clone</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 关联检测框和骨架</span></span><br><span class="line">      std::vector&lt;PersonDescriptor&gt; current_persons;</span><br><span class="line">      <span class="built_in">associateDetectionsWithSkeletons</span>(det_msg, skel_msg, current_persons);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 为每个人物提取特征</span></span><br><span class="line">      <span class="built_in">extractFeatures</span>(image, current_persons);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 与数据库中的人物匹配并分配ID</span></span><br><span class="line">      <span class="built_in">matchAndAssignIDs</span>(current_persons);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 更新数据库</span></span><br><span class="line">      <span class="built_in">updateDatabase</span>(current_persons);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 发布结果</span></span><br><span class="line">      <span class="built_in">publishResults</span>(img_msg-&gt;header, current_persons);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">      <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Error in person ReID: %s&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">associateDetectionsWithSkeletons</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> vision_msgs::Detection2DArray::ConstPtr&amp; det_msg,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> openpose_ros_msgs::PersonArray::ConstPtr&amp; skel_msg,</span></span></span><br><span class="line"><span class="params"><span class="function">      std::vector&lt;PersonDescriptor&gt;&amp; persons)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对每个检测框</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; detection : det_msg-&gt;detections) &#123;</span><br><span class="line">      <span class="comment">// 只处理人类检测结果</span></span><br><span class="line">      <span class="keyword">if</span> (detection.results[<span class="number">0</span>].id != <span class="string">&quot;person&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line">      </span><br><span class="line">      PersonDescriptor person;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 提取边界框</span></span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; bbox = detection.bbox;</span><br><span class="line">      person.bbox = cv::<span class="built_in">Rect</span>(</span><br><span class="line">        bbox.center.x - bbox.size_x/<span class="number">2</span>,</span><br><span class="line">        bbox.center.y - bbox.size_y/<span class="number">2</span>,</span><br><span class="line">        bbox.size_x,</span><br><span class="line">        bbox.size_y</span><br><span class="line">      );</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 找到最匹配的骨架</span></span><br><span class="line">      <span class="type">int</span> best_skeleton_idx = <span class="number">-1</span>;</span><br><span class="line">      <span class="type">float</span> best_iou = <span class="number">0.3</span>;  <span class="comment">// 最小IOU阈值</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; skel_msg-&gt;persons.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 计算骨架边界框</span></span><br><span class="line">        cv::Rect skel_bbox = <span class="built_in">calculateSkeletonBBox</span>(skel_msg-&gt;persons[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算IOU</span></span><br><span class="line">        <span class="type">float</span> iou = <span class="built_in">calculateIOU</span>(person.bbox, skel_bbox);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (iou &gt; best_iou) &#123;</span><br><span class="line">          best_iou = iou;</span><br><span class="line">          best_skeleton_idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果找到匹配的骨架，提取关键点</span></span><br><span class="line">      <span class="keyword">if</span> (best_skeleton_idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; skeleton = skel_msg-&gt;persons[best_skeleton_idx];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; keypoint : skeleton.keypoints) &#123;</span><br><span class="line">          <span class="comment">// 只保留置信度较高的关键点</span></span><br><span class="line">          <span class="keyword">if</span> (keypoint.confidence &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">            person.skeleton.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(keypoint.position.x, keypoint.position.y));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            person.skeleton.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(<span class="number">-1</span>, <span class="number">-1</span>));  <span class="comment">// 无效关键点</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        persons.<span class="built_in">push_back</span>(person);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">cv::Rect <span class="title">calculateSkeletonBBox</span><span class="params">(<span class="type">const</span> openpose_ros_msgs::Person&amp; person)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> min_x = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="type">float</span> min_y = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="type">float</span> max_x = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">lowest</span>();</span><br><span class="line">    <span class="type">float</span> max_y = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">lowest</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> valid_points = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; keypoint : person.keypoints) &#123;</span><br><span class="line">      <span class="keyword">if</span> (keypoint.confidence &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        min_x = std::<span class="built_in">min</span>(min_x, keypoint.position.x);</span><br><span class="line">        min_y = std::<span class="built_in">min</span>(min_y, keypoint.position.y);</span><br><span class="line">        max_x = std::<span class="built_in">max</span>(max_x, keypoint.position.x);</span><br><span class="line">        max_y = std::<span class="built_in">max</span>(max_y, keypoint.position.y);</span><br><span class="line">        valid_points++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (valid_points &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cv::<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 无效骨架</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cv::<span class="built_in">Rect</span>(min_x, min_y, max_x - min_x, max_y - min_y);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">calculateIOU</span><span class="params">(<span class="type">const</span> cv::Rect&amp; rect1, <span class="type">const</span> cv::Rect&amp; rect2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算交集区域</span></span><br><span class="line">    <span class="type">int</span> x_left = std::<span class="built_in">max</span>(rect<span class="number">1.</span>x, rect<span class="number">2.</span>x);</span><br><span class="line">    <span class="type">int</span> y_top = std::<span class="built_in">max</span>(rect<span class="number">1.</span>y, rect<span class="number">2.</span>y);</span><br><span class="line">    <span class="type">int</span> x_right = std::<span class="built_in">min</span>(rect<span class="number">1.</span>x + rect<span class="number">1.</span>width, rect<span class="number">2.</span>x + rect<span class="number">2.</span>width);</span><br><span class="line">    <span class="type">int</span> y_bottom = std::<span class="built_in">min</span>(rect<span class="number">1.</span>y + rect<span class="number">1.</span>height, rect<span class="number">2.</span>y + rect<span class="number">2.</span>height);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x_right &lt; x_left || y_bottom &lt; y_top) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0.0f</span>;  <span class="comment">// 没有交集</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> intersection_area = (x_right - x_left) * (y_bottom - y_top);</span><br><span class="line">    <span class="type">float</span> rect1_area = rect<span class="number">1.</span>width * rect<span class="number">1.</span>height;</span><br><span class="line">    <span class="type">float</span> rect2_area = rect<span class="number">2.</span>width * rect<span class="number">2.</span>height;</span><br><span class="line">    <span class="type">float</span> union_area = rect1_area + rect2_area - intersection_area;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> intersection_area / union_area;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">extractFeatures</span><span class="params">(<span class="type">const</span> cv::Mat&amp; image, std::vector&lt;PersonDescriptor&gt;&amp; persons)</span> </span>&#123;</span><br><span class="line">    torch::NoGradGuard no_grad;  <span class="comment">// 禁用梯度计算</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; person : persons) &#123;</span><br><span class="line">      <span class="comment">// 提取RGB特征</span></span><br><span class="line">      cv::Mat person_img = <span class="built_in">image</span>(person.bbox).<span class="built_in">clone</span>();</span><br><span class="line">      cv::<span class="built_in">resize</span>(person_img, person_img, cv::<span class="built_in">Size</span>(<span class="number">128</span>, <span class="number">256</span>));</span><br><span class="line">      </span><br><span class="line">      torch::Tensor img_tensor = torch::<span class="built_in">from_blob</span>(</span><br><span class="line">        person_img.data, </span><br><span class="line">        &#123;<span class="number">1</span>, person_img.rows, person_img.cols, <span class="number">3</span>&#125;,</span><br><span class="line">        torch::kByte</span><br><span class="line">      ).<span class="built_in">to</span>(torch::kFloat);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 转换为NCHW格式，归一化</span></span><br><span class="line">      img_tensor = img_tensor.<span class="built_in">permute</span>(&#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">      img_tensor = img_tensor.<span class="built_in">div</span>(<span class="number">255.0</span>);</span><br><span class="line">      img_tensor = img_tensor.<span class="built_in">sub</span>(torch::<span class="built_in">tensor</span>(&#123;<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>&#125;).<span class="built_in">view</span>(&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>&#125;))</span><br><span class="line">                             .<span class="built_in">div</span>(torch::<span class="built_in">tensor</span>(&#123;<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>&#125;).<span class="built_in">view</span>(&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>&#125;));</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 提取RGB特征</span></span><br><span class="line">      std::vector&lt;torch::jit::IValue&gt; inputs;</span><br><span class="line">      inputs.<span class="built_in">push_back</span>(img_tensor);</span><br><span class="line">      torch::Tensor rgb_feat = rgb_model_.forward(inputs).<span class="built_in">toTensor</span>();</span><br><span class="line">      person.rgb_feat = rgb_feat.<span class="built_in">detach</span>().<span class="built_in">to</span>(torch::kCPU);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 提取骨架特征</span></span><br><span class="line">      torch::Tensor skel_tensor = <span class="built_in">preprocess_skeleton</span>(person.skeleton);</span><br><span class="line">      inputs.<span class="built_in">clear</span>();</span><br><span class="line">      inputs.<span class="built_in">push_back</span>(skel_tensor);</span><br><span class="line">      torch::Tensor skel_feat = skel_model_.forward(inputs).<span class="built_in">toTensor</span>();</span><br><span class="line">      person.skel_feat = skel_feat.<span class="built_in">detach</span>().<span class="built_in">to</span>(torch::kCPU);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 融合特征</span></span><br><span class="line">      person.fused_feat = fusion_alpha_ * person.rgb_feat + </span><br><span class="line">                          (<span class="number">1.0f</span> - fusion_alpha_) * person.skel_feat;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 特征归一化</span></span><br><span class="line">      person.fused_feat = person.fused_feat.<span class="built_in">div</span>(person.fused_feat.<span class="built_in">norm</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">torch::Tensor <span class="title">preprocess_skeleton</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt;&amp; skeleton)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将骨架转换为模型输入格式</span></span><br><span class="line">    <span class="comment">// 简化版：将骨架关键点坐标展平为向量</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num_joints = skeleton.<span class="built_in">size</span>();</span><br><span class="line">    torch::Tensor skel_tensor = torch::<span class="built_in">zeros</span>(&#123;<span class="number">1</span>, num_joints * <span class="number">2</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到有效关键点的重心作为标准化基准</span></span><br><span class="line">    <span class="type">float</span> center_x = <span class="number">0.0f</span>, center_y = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">int</span> valid_points = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; joint : skeleton) &#123;</span><br><span class="line">      <span class="keyword">if</span> (joint.x &gt;= <span class="number">0</span> &amp;&amp; joint.y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        center_x += joint.x;</span><br><span class="line">        center_y += joint.y;</span><br><span class="line">        valid_points++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (valid_points &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      center_x /= valid_points;</span><br><span class="line">      center_y /= valid_points;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算标准化尺度</span></span><br><span class="line">    <span class="type">float</span> scale = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; joint : skeleton) &#123;</span><br><span class="line">      <span class="keyword">if</span> (joint.x &gt;= <span class="number">0</span> &amp;&amp; joint.y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> dx = joint.x - center_x;</span><br><span class="line">        <span class="type">float</span> dy = joint.y - center_y;</span><br><span class="line">        scale += std::<span class="built_in">sqrt</span>(dx*dx + dy*dy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (valid_points &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      scale /= valid_points;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (scale &lt; <span class="number">1e-3</span>) scale = <span class="number">1.0f</span>;  <span class="comment">// 避免除零</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填充标准化后的关键点坐标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_joints; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (skeleton[i].x &gt;= <span class="number">0</span> &amp;&amp; skeleton[i].y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        skel_tensor[<span class="number">0</span>][i*<span class="number">2</span>] = (skeleton[i].x - center_x) / scale;</span><br><span class="line">        skel_tensor[<span class="number">0</span>][i*<span class="number">2</span><span class="number">+1</span>] = (skeleton[i].y - center_y) / scale;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> skel_tensor;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">matchAndAssignIDs</span><span class="params">(std::vector&lt;PersonDescriptor&gt;&amp; persons)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果数据库为空，为所有人物分配新ID</span></span><br><span class="line">    <span class="keyword">if</span> (person_database_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; person : persons) &#123;</span><br><span class="line">        person.id = next_id_++;</span><br><span class="line">        person.match_count = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建相似度矩阵</span></span><br><span class="line">    <span class="type">int</span> n_db = person_database_.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n_current = persons.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">float</span>&gt;&gt; <span class="built_in">similarity_matrix</span>(n_current, std::<span class="built_in">vector</span>&lt;<span class="type">float</span>&gt;(n_db, <span class="number">0.0f</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_current; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n_db; j++) &#123;</span><br><span class="line">        <span class="comment">// 计算特征向量的余弦相似度</span></span><br><span class="line">        torch::Tensor sim = torch::<span class="built_in">cosine_similarity</span>(</span><br><span class="line">          persons[i].fused_feat, </span><br><span class="line">          person_database_[j].fused_feat</span><br><span class="line">        );</span><br><span class="line">        similarity_matrix[i][j] = sim.<span class="built_in">item</span>&lt;<span class="type">float</span>&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用匈牙利算法求解最优匹配</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; assignments = <span class="built_in">hungarianMatching</span>(similarity_matrix);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据匹配结果分配ID</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_current; i++) &#123;</span><br><span class="line">      <span class="type">int</span> db_idx = assignments[i];</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (db_idx &gt;= <span class="number">0</span> &amp;&amp; similarity_matrix[i][db_idx] &gt; match_threshold_) &#123;</span><br><span class="line">        <span class="comment">// 找到匹配，使用已有ID</span></span><br><span class="line">        persons[i].id = person_database_[db_idx].id;</span><br><span class="line">        persons[i].match_count = person_database_[db_idx].match_count + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未找到匹配，分配新ID</span></span><br><span class="line">        persons[i].id = next_id_++;</span><br><span class="line">        persons[i].match_count = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">hungarianMatching</span><span class="params">(<span class="type">const</span> std::vector&lt;std::vector&lt;<span class="type">float</span>&gt;&gt;&amp; similarity_matrix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 简化版匈牙利算法实现</span></span><br><span class="line">    <span class="comment">// 在实际应用中应使用成熟的库如Munkres算法</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n_rows = similarity_matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n_rows == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n_cols = similarity_matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">assignments</span><span class="params">(n_rows, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 简化：贪心匹配</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">col_assigned</span><span class="params">(n_cols, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_rows; i++) &#123;</span><br><span class="line">      <span class="type">int</span> best_j = <span class="number">-1</span>;</span><br><span class="line">      <span class="type">float</span> best_sim = match_threshold_;  <span class="comment">// 最小相似度阈值</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n_cols; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!col_assigned[j] &amp;&amp; similarity_matrix[i][j] &gt; best_sim) &#123;</span><br><span class="line">          best_sim = similarity_matrix[i][j];</span><br><span class="line">          best_j = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (best_j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        assignments[i] = best_j;</span><br><span class="line">        col_assigned[best_j] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> assignments;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">updateDatabase</span><span class="params">(<span class="type">const</span> std::vector&lt;PersonDescriptor&gt;&amp; current_persons)</span> </span>&#123;</span><br><span class="line">    ros::Time current_time = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前识别的人物添加到数据库</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; person : current_persons) &#123;</span><br><span class="line">      <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 查找并更新已有记录</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; db_person : person_database_) &#123;</span><br><span class="line">        <span class="keyword">if</span> (db_person.id == person.id) &#123;</span><br><span class="line">          <span class="comment">// 更新现有记录</span></span><br><span class="line">          db_person.bbox = person.bbox;</span><br><span class="line">          db_person.skeleton = person.skeleton;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 特征平滑更新</span></span><br><span class="line">          db_person.rgb_feat = <span class="number">0.7</span> * db_person.rgb_feat + <span class="number">0.3</span> * person.rgb_feat;</span><br><span class="line">          db_person.skel_feat = <span class="number">0.7</span> * db_person.skel_feat + <span class="number">0.3</span> * person.skel_feat;</span><br><span class="line">          db_person.fused_feat = <span class="number">0.7</span> * db_person.fused_feat + <span class="number">0.3</span> * person.fused_feat;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 归一化更新后的特征</span></span><br><span class="line">          db_person.fused_feat = db_person.fused_feat.<span class="built_in">div</span>(db_person.fused_feat.<span class="built_in">norm</span>());</span><br><span class="line">          </span><br><span class="line">          db_person.last_seen = current_time;</span><br><span class="line">          db_person.match_count = person.match_count;</span><br><span class="line">          </span><br><span class="line">          found = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">        <span class="comment">// 添加新记录</span></span><br><span class="line">        PersonDescriptor new_db_person = person;</span><br><span class="line">        new_db_person.last_seen = current_time;</span><br><span class="line">        person_database_.<span class="built_in">push_back</span>(new_db_person);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除长时间未出现的人物</span></span><br><span class="line">    <span class="function">ros::Duration <span class="title">max_absence</span><span class="params">(<span class="number">10.0</span>)</span></span>;  <span class="comment">// 10秒</span></span><br><span class="line">    std::vector&lt;PersonDescriptor&gt; retained_persons;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; db_person : person_database_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (current_time - db_person.last_seen &lt; max_absence) &#123;</span><br><span class="line">        retained_persons.<span class="built_in">push_back</span>(db_person);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    person_database_ = retained_persons;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">publishResults</span><span class="params">(<span class="type">const</span> std_msgs::Header&amp; header, </span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> std::vector&lt;PersonDescriptor&gt;&amp; persons)</span> </span>&#123;</span><br><span class="line">    vision_msgs::Detection2DArray reid_msg;</span><br><span class="line">    reid_msg.header = header;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; person : persons) &#123;</span><br><span class="line">      vision_msgs::Detection2D detection;</span><br><span class="line">      detection.header = header;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 边界框</span></span><br><span class="line">      detection.bbox.center.x = person.bbox.x + person.bbox.width / <span class="number">2</span>;</span><br><span class="line">      detection.bbox.center.y = person.bbox.y + person.bbox.height / <span class="number">2</span>;</span><br><span class="line">      detection.bbox.size_x = person.bbox.width;</span><br><span class="line">      detection.bbox.size_y = person.bbox.height;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ID和置信度</span></span><br><span class="line">      vision_msgs::ObjectHypothesisWithPose hypothesis;</span><br><span class="line">      hypothesis.id = <span class="string">&quot;person_&quot;</span> + std::<span class="built_in">to_string</span>(person.id);</span><br><span class="line">      hypothesis.score = <span class="number">1.0</span>;  <span class="comment">// 置信度</span></span><br><span class="line">      detection.results.<span class="built_in">push_back</span>(hypothesis);</span><br><span class="line">      </span><br><span class="line">      reid_msg.detections.<span class="built_in">push_back</span>(detection);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reid_pub_.<span class="built_in">publish</span>(reid_msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_reid_node&quot;</span>);</span><br><span class="line">  PersonReID reid_system;</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-多模态融合与持续学习"><a href="#3-5-多模态融合与持续学习" class="headerlink" title="3.5 多模态融合与持续学习"></a>3.5 多模态融合与持续学习</h3><p>在RGB与骨架融合的人物ID识别中，还有两个高级技术可进一步提升系统性能：</p>
<p><strong>多阶段融合架构</strong>：</p>
<ul>
<li>不同于简单的特征连接或加权融合，多阶段融合同时利用早期、中期和后期融合的优势</li>
<li>通过注意力机制，自适应地分配不同模态的重要性权重</li>
<li>优势：更好地处理模态缺失、噪声干扰问题</li>
<li>典型实现：多模态变换器(Multi-modal Transformer)、跨模态注意力网络</li>
</ul>
<p><strong>在线持续学习</strong>：</p>
<ul>
<li>系统不仅能识别已知人物，还能自适应地学习新出现的人物特征</li>
<li>使用在线度量学习，动态更新特征提取模型权重</li>
<li>优势：随着系统运行时间延长，识别精度不断提高</li>
<li>典型实现：对比学习(Contrastive Learning)、原型网络(Prototypical Networks)</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>在ROS中实现人体骨架定位、跟踪和ID识别是构建智能人机交互系统的基础。通过本文介绍的三种核心技术，可以构建完整的人体感知系统：</p>
<ol>
<li><p><strong>人体骨架定位</strong>：利用深度学习模型从RGB或深度图像中提取人体关键点，构建骨架模型。这是人体感知的第一步，为后续分析提供基础数据。</p>
</li>
<li><p><strong>人体跟踪</strong>：使用卡尔曼滤波等预测算法和数据关联技术，实现对多个人体目标的持续跟踪。这解决了运动中的人体身份一致性问题，是人机交互中的关键环节。</p>
</li>
<li><p><strong>RGB与骨架的人物ID识别</strong>：结合视觉外观和骨架特征，进行多模态融合识别，提高系统鲁棒性和准确率。这使系统能够在不同场景下持续识别特定人物，支持个性化交互。</p>
</li>
</ol>
<p>这三种技术相互配合，共同构成了完整的人体感知系统。在实际应用中，可根据具体需求和计算资源，选择合适的算法和模型，实现高效准确的人体感知与交互功能。</p>
<h1 id="extern-2"><a href="#extern-2" class="headerlink" title="extern 2:"></a>extern 2:</h1><p>注意力机制，RGB骨架和transformer<br>1.首先为什么使用注意力机制:<br>结构化信息保留：简单的全连接网络会丢失模态间的结构化关系，而注意力机制能保留并强化这些关系。<br>2.transformer的多头注意力确确实实把所有信息计算了一遍，然后经过全连接&#x2F;下一个transformer，然后不同的Q，K，V是有不同含义的:<br>Q矩阵学习检测”我需要主语信息”或”我需要动词的宾语”等查询模式<br>K矩阵学习表达”我是名词”或”我是介词”等身份信息<br>V矩阵学习表达”我的实际语义内容是什么”</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/22/ROS_%E7%AE%97%E6%B3%95/" data-id="cm8l9ohw900008sydglh26jxj" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-我的部分解答思路" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/20/%E6%88%91%E7%9A%84%E9%83%A8%E5%88%86%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF/" class="article-date">
  <time class="dt-published" datetime="2025-03-19T18:56:50.106Z" itemprop="datePublished">2025-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="组合与概率详细解答"><a href="#组合与概率详细解答" class="headerlink" title="组合与概率详细解答"></a>组合与概率详细解答</h1><hr>
<h2 id="1-双边布朗运动的最大值分布"><a href="#1-双边布朗运动的最大值分布" class="headerlink" title="1. 双边布朗运动的最大值分布"></a>1. 双边布朗运动的最大值分布</h2><p><strong>题目</strong>：证明 $((X_{T+s})<em>{s \geq 0})$ 和 $((X</em>{T-s})_{s \geq 0})$ 同分布。</p>
<p><strong>关键思路</strong>：  </p>
<ol>
<li><p><strong>对称性与独立性</strong>：  </p>
<ul>
<li>双边布朗运动 $B_t$ 在正负时间轴独立，且 $B_t - |t|$ 的增量具有对称性。  </li>
<li>最大值点 $T$ 是唯一的，且关于原点对称（由布朗运动反射原理）。</li>
</ul>
</li>
<li><p><strong>路径变换</strong>：  </p>
<ul>
<li>定义时间反转过程 $\tilde{B}<em>s &#x3D; B</em>{T-s} - (T - s)$，验证其满足布朗运动性质。  </li>
<li>由于 $X_{T+s} &#x3D; B_{T+s} - (T + s)$ 和 $X_{T-s} &#x3D; B_{T-s} - (T - s)$，路径的统计特性相同。</li>
</ul>
</li>
<li><p><strong>有限维分布一致性</strong>：  </p>
<ul>
<li>对任意有限个时间点 $s_1, \ldots, s_k$，联合分布 $(X_{T+s_1}, \ldots, X_{T+s_k})$ 与 $(X_{T-s_1}, \ldots, X_{T-s_k})$ 相同。</li>
</ul>
</li>
</ol>
<p><strong>严格证明步骤</strong>：  </p>
<ul>
<li>通过布朗运动的强马尔可夫性，最大值点 $T$ 是停时。  </li>
<li>应用反射原理：对 $s \geq 0$，过程 ${X_{T+s}}$ 和 ${X_{T-s}}$ 的增量独立且同分布。</li>
</ul>
<hr>
<h2 id="2-双随机矩阵的置换匹配"><a href="#2-双随机矩阵的置换匹配" class="headerlink" title="2. 双随机矩阵的置换匹配"></a>2. 双随机矩阵的置换匹配</h2><p><strong>结论</strong>：$f(n) &#x3D; \frac{1}{n}$，即每个双随机矩阵存在置换 $P$ 使得 $M_{i,P(i)} \geq \frac{1}{n}$。</p>
<p><strong>证明</strong>：  </p>
<ol>
<li><p><strong>Birkhoff-von Neumann 定理</strong>：  </p>
<ul>
<li>任何双随机矩阵可表示为置换矩阵的凸组合：$M &#x3D; \sum_{k&#x3D;1}^K \lambda_k P_k$，其中 $\lambda_k \geq 0$，$\sum \lambda_k &#x3D; 1$。  </li>
<li>取权重最大的置换 $P_k$，则 $\lambda_k \geq \frac{1}{n!}$，但此方法不够直接。</li>
</ul>
</li>
<li><p><strong>极值情况分析</strong>：  </p>
<ul>
<li>均匀矩阵 $M_{ij} &#x3D; \frac{1}{n}$ 是双随机的。  </li>
<li>对任意置换 $P$，有 $M_{i,P(i)} &#x3D; \frac{1}{n}$，因此 $f(n) \leq \frac{1}{n}$。</li>
</ul>
</li>
<li><p><strong>存在性构造</strong>：  </p>
<ul>
<li>应用 König 定理（二分图匹配）：双随机矩阵对应二分图的完美匹配，且最小边权至少为 $\frac{1}{n}$。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-均匀变量的统计量性质"><a href="#3-均匀变量的统计量性质" class="headerlink" title="3. 均匀变量的统计量性质"></a>3. 均匀变量的统计量性质</h2><p><strong>(a) $S(U_1, \ldots, U_n)$ 是标准均匀变量</strong></p>
<p><strong>步骤</strong>：  </p>
<ol>
<li><p><strong>顺序统计量分布</strong>：  </p>
<ul>
<li>第 $i$ 个顺序统计量 $U_{(i)}$ 服从 Beta 分布 $B(i, n-i+1)$，密度为 $f_{U_{(i)}}(u) &#x3D; \frac{n!}{(i-1)!(n-i)!} u^{i-1}(1-u)^{n-i}$。</li>
</ul>
</li>
<li><p><strong>最小尺度统计量的分布</strong>：  </p>
<ul>
<li>定义 $S &#x3D; \min_{i} \frac{n}{i} U_{(i)}$，计算其生存函数：<br>[<br>]<br>[<br> P(S &gt; t) &#x3D; P\left(\bigcap_{i&#x3D;1}^n \left{\frac{n}{i} U_{(i)} &gt; t\right}\right) &#x3D; \prod_{i&#x3D;1}^n P\left(U_{(i)} &gt; \frac{it}{n}\right).<br>]</li>
<li>通过积分验证 $P(S \leq t) &#x3D; t$，即 $S \sim U(0,1)$。</li>
</ul>
</li>
</ol>
<p><strong>(b) $M_r$ 是次均匀当且仅当 $r \leq -1$</strong></p>
<p><strong>步骤</strong>：  </p>
<ol>
<li><p><strong>幂平均的单调性</strong>：  </p>
<ul>
<li>当 $r \leq -1$，$M_r$ 是凹函数，分布尾部更重，满足 $P(M_r \leq t) \geq t$。  </li>
<li>当 $r &gt; -1$，$M_r$ 是凸函数，分布尾部衰减更快，存在 $t$ 使得 $P(M_r \leq t) &lt; t$。</li>
</ul>
</li>
<li><p><strong>反例构造</strong>：  </p>
<ul>
<li>取 $r &#x3D; 1$（算术平均），则 $M_1$ 的期望为 $\frac{1}{2}$，但 $P(M_1 \leq 0.5) &lt; 0.5$（因分布集中在均值附近）。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="应用与计算数学详细解答"><a href="#应用与计算数学详细解答" class="headerlink" title="应用与计算数学详细解答"></a>应用与计算数学详细解答</h1><hr>
<h2 id="1-高斯-赛德尔迭代"><a href="#1-高斯-赛德尔迭代" class="headerlink" title="1. 高斯-赛德尔迭代"></a>1. 高斯-赛德尔迭代</h2><p><strong>(a) 收敛性证明</strong></p>
<p><strong>步骤</strong>：  </p>
<ol>
<li><p><strong>矩阵分裂</strong>：  </p>
<ul>
<li>将 $A$ 分解为 $A &#x3D; D - L - U$，其中 $D$ 为对角矩阵，$L$ 和 $U$ 分别为严格下三角和上三角矩阵。  </li>
<li>迭代矩阵 $G &#x3D; (D - L)^{-1}U$。</li>
</ul>
</li>
<li><p><strong>谱半径分析</strong>：  </p>
<ul>
<li>对称正定矩阵的谱半径 $\rho(G) &lt; 1$，故迭代收敛。</li>
</ul>
</li>
</ol>
<p><strong>(b) 对角矩阵一步收敛</strong></p>
<p><strong>验证</strong>：  </p>
<ul>
<li>若 $A$ 为对角矩阵，则 $L &#x3D; U &#x3D; 0$，迭代公式简化为 $x_i^{(k+1)} &#x3D; \frac{b_i}{A_{ii}}$，即一步达到精确解。</li>
</ul>
<hr>
<h2 id="2-奖励模型优化"><a href="#2-奖励模型优化" class="headerlink" title="2. 奖励模型优化"></a>2. 奖励模型优化</h2><p><strong>(a) 凹性与唯一解</strong></p>
<p><strong>步骤</strong>：  </p>
<ol>
<li><strong>目标函数的凹性</strong>：  <ul>
<li>$G$ 强凹且单调递增，$\sum G(r_i - r_j)$ 是凹函数（Hessian矩阵负定）。  </li>
<li>约束 $0 \leq r_1 &lt; \cdots &lt; r_n \leq 1$ 是凸集，故优化问题存在唯一解。</li>
</ul>
</li>
</ol>
<p><strong>(b) 解的结构对称性</strong></p>
<p><strong>推导</strong>：  </p>
<ul>
<li>假设最优解不对称，则存在 $r_i + r_{n+1-i} \neq 1$，可通过调整对称位置的值增大目标函数，矛盾。</li>
</ul>
<p><strong>(c) 测度不变性</strong></p>
<p><strong>思路</strong>：  </p>
<ul>
<li>极值测度 $\mu^*$ 必为均匀分布（对称性最大化差异），故 $\mathbb{E}[G(|X - c|)]$ 与 $c$ 无关。</li>
</ul>
<hr>
<h2 id="3-粒子系统的随机微分方程"><a href="#3-粒子系统的随机微分方程" class="headerlink" title="3. 粒子系统的随机微分方程"></a>3. 粒子系统的随机微分方程</h2><p><strong>(a) 福克-普朗克方程</strong></p>
<p><strong>推导</strong>：  </p>
<ol>
<li><strong>生成元法</strong>：  <ul>
<li>粒子系统的漂移项为 $-U’(x_i) - \theta(x_i - \frac{1}{N}\sum x_k)$，扩散项为 $\sigma dW_t^i$。  </li>
<li>FP方程为：<br>[<br>\partial_t F_N &#x3D; \sum_{i&#x3D;1}^N \partial_{x_i} \left[ \left(U’(x_i) + \theta\left(x_i - \frac{1}{N}\sum x_k\right)\right) F_N \right] + \frac{\sigma^2}{2} \sum_{i&#x3D;1}^N \partial_{x_i}^2 F_N.<br>]</li>
</ul>
</li>
</ol>
<p><strong>(b) 相对熵有界性</strong></p>
<p><strong>工具</strong>：  </p>
<ul>
<li>利用熵不等式 $\partial_t H \leq C H + D$，结合 Gronwall 引理得 $H(t) \leq C_T$。</li>
</ul>
<h1 id="组合与概率第1题详细解答"><a href="#组合与概率第1题详细解答" class="headerlink" title="组合与概率第1题详细解答"></a>组合与概率第1题详细解答</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设 $B_t$ 是满足以下条件的双边布朗运动：  </p>
<ul>
<li>$(B_t)<em>{t \geq 0}$ 和 $(B</em>{-t})_{t \geq 0}$ 是独立的标准布朗运动，  </li>
<li>$B_0 &#x3D; 0$。</li>
</ul>
<p>定义随机过程 $X_t &#x3D; B_t - |t|$，并令 $T$ 为几乎必然唯一的时间，使得 $X_T &#x3D; \max_{s \in \mathbb{R}} X_s$。<br>需证明：$(X_{T+s})<em>{s \geq 0}$ 和 $(X</em>{T-s})_{s \geq 0}$ 同分布。</p>
<hr>
<h2 id="关键思路"><a href="#关键思路" class="headerlink" title="关键思路"></a>关键思路</h2><ol>
<li><p><strong>最大值点的唯一性</strong>：  </p>
<ul>
<li>由于 $X_t &#x3D; B_t - |t|$ 在 $|t| \to \infty$ 时趋于 $-\infty$，且路径连续，故最大值点 $T$ 几乎必然存在且唯一。</li>
</ul>
</li>
<li><p><strong>布朗运动的对称性</strong>：  </p>
<ul>
<li>双边布朗运动在正负时间轴上独立且对称。  </li>
<li>最大值点 $T$ 的位置在时间轴上具有对称性（无偏向性）。</li>
</ul>
</li>
<li><p><strong>路径重构与同分布</strong>：  </p>
<ul>
<li>从 $T$ 出发，正向和反向路径可通过对称变换构造同分布过程。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="严格证明步骤"><a href="#严格证明步骤" class="headerlink" title="严格证明步骤"></a>严格证明步骤</h2><h3 id="步骤1：定义时间反转过程"><a href="#步骤1：定义时间反转过程" class="headerlink" title="步骤1：定义时间反转过程"></a>步骤1：定义时间反转过程</h3><p>构造反向过程 $\tilde{B}_s$：  </p>
<ul>
<li>对 $s \geq 0$，定义 $\tilde{B}<em>s &#x3D; B</em>{T - s} - (T - s)$。  </li>
<li>由于 $(B_{-t})_{t \geq 0}$ 是独立布朗运动，$\tilde{B}_s$ 在 $s \geq 0$ 上仍是标准布朗运动。</li>
</ul>
<h3 id="步骤2：验证路径同分布"><a href="#步骤2：验证路径同分布" class="headerlink" title="步骤2：验证路径同分布"></a>步骤2：验证路径同分布</h3><p>正向过程：<br>$$ X_{T+s} &#x3D; B_{T+s} - (T + s). $$<br>反向过程：<br>$$ X_{T-s} &#x3D; B_{T-s} - (T - s) &#x3D; \tilde{B}_s - s. $$  </p>
<p>由于 ${B_{T+s} - B_T}<em>{s \geq 0}$ 和 ${\tilde{B}<em>s}</em>{s \geq 0}$ 均为独立的标准布朗运动，且与 $B_T$ 独立，因此：<br>$$ (X</em>{T+s})<em>{s \geq 0} \stackrel{d}{&#x3D;} (\tilde{B}<em>s - s)</em>{s \geq 0} \stackrel{d}{&#x3D;} (X</em>{T-s})_{s \geq 0}. $$  </p>
<h3 id="步骤3：形式化应用强马尔可夫性"><a href="#步骤3：形式化应用强马尔可夫性" class="headerlink" title="步骤3：形式化应用强马尔可夫性"></a>步骤3：形式化应用强马尔可夫性</h3><ul>
<li>$T$ 是停时，因 $T$ 由过程历史决定。  </li>
<li>强马尔可夫性表明，过程在 $T$ 后的增量独立于过去，且保持布朗运动性质。  </li>
<li>反向过程 $\tilde{B}_s$ 继承了原过程的独立增量性，从而保证同分布。</li>
</ul>
<h3 id="步骤4：有限维分布一致性"><a href="#步骤4：有限维分布一致性" class="headerlink" title="步骤4：有限维分布一致性"></a>步骤4：有限维分布一致性</h3><p>对任意 $s_1, \ldots, s_k \geq 0$，联合分布满足：<br>$$ (X_{T+s_1}, \ldots, X_{T+s_k}) \stackrel{d}{&#x3D;} (X_{T-s_1}, \ldots, X_{T-s_k}). $$<br>通过计算特征函数或密度函数可严格验证。</p>
<hr>
<h2 id="直观解释"><a href="#直观解释" class="headerlink" title="直观解释"></a>直观解释</h2><p>最大值点 $T$ 是时间轴上的对称中心。正向路径 $X_{T+s}$ 是布朗运动从 $T$ 向右扩散并减去时间增长项，反向路径 $X_{T-s}$ 则是从 $T$ 向左的镜像过程减去时间递减项。由于布朗运动在任意起点的增量性质相同，两者的统计行为完全一致。</p>
<h1 id="组合与概率第2题详细解答"><a href="#组合与概率第2题详细解答" class="headerlink" title="组合与概率第2题详细解答"></a>组合与概率第2题详细解答</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>对每个正整数 ( n )，找出最大的实数 ( f(n) )，使得对每个 ( n \times n ) 双随机矩阵 ( M )（元素非负且每行每列和为1），均存在一个置换矩阵 ( P )，满足：<br>$$ M_{i,P(i)} \geq f(n), \quad \forall i \in [n]. $$</p>
<hr>
<h2 id="关键思路-1"><a href="#关键思路-1" class="headerlink" title="关键思路"></a>关键思路</h2><ol>
<li><strong>极值构造</strong>：均匀双随机矩阵 ( M_{i,j} &#x3D; \frac{1}{n} ) 表明 ( f(n) \leq \frac{1}{n} )。</li>
<li><strong>存在性证明</strong>：利用二分图完美匹配理论（Hall定理）证明对任意双随机矩阵，存在置换使得所有选中元素 ( \geq \frac{1}{n} )。</li>
</ol>
<hr>
<h2 id="严格证明"><a href="#严格证明" class="headerlink" title="严格证明"></a>严格证明</h2><h3 id="步骤1：构造二分图"><a href="#步骤1：构造二分图" class="headerlink" title="步骤1：构造二分图"></a>步骤1：构造二分图</h3><ul>
<li><strong>顶点划分</strong>：左部节点为行 ( {1, 2, \ldots, n} )，右部节点为列 ( {1’, 2’, \ldots, n’} )。</li>
<li><strong>边定义</strong>：边 ( (i, j’) ) 存在当且仅当 ( M_{i,j} \geq \frac{1}{n} )。</li>
</ul>
<h3 id="步骤2：验证Hall条件"><a href="#步骤2：验证Hall条件" class="headerlink" title="步骤2：验证Hall条件"></a>步骤2：验证Hall条件</h3><p>需证明：对任意子集 ( S \subseteq {1, 2, \ldots, n} )，其邻居集合 ( N(S) ) 满足 ( |N(S)| \geq |S| )。<br><strong>反证法</strong>：<br>假设存在 ( S ) 使得 ( |N(S)| &lt; |S| )。则：</p>
<ul>
<li>( S ) 中行的所有非零元素仅分布在 ( N(S) ) 的列中。</li>
<li>每行的和为1，故 ( S ) 的行总权重为 ( |S| \times 1 &#x3D; |S| )。</li>
<li>但 ( N(S) ) 的列总容量为 ( |N(S)| \times 1 &#x3D; |N(S)| &lt; |S| )，矛盾（因 ( M ) 的双随机性要求总权重守恒）。</li>
</ul>
<h3 id="步骤3：存在完美匹配"><a href="#步骤3：存在完美匹配" class="headerlink" title="步骤3：存在完美匹配"></a>步骤3：存在完美匹配</h3><p>根据Hall定理，二分图存在完美匹配，对应置换矩阵 ( P ) 满足 ( M_{i,P(i)} \geq \frac{1}{n} )。</p>
<h3 id="步骤4：极值性验证"><a href="#步骤4：极值性验证" class="headerlink" title="步骤4：极值性验证"></a>步骤4：极值性验证</h3><p>取均匀矩阵 ( M_{i,j} &#x3D; \frac{1}{n} )，则对任意置换 ( P )，均有 ( M_{i,P(i)} &#x3D; \frac{1}{n} )，故 ( f(n) \leq \frac{1}{n} )。</p>
<hr>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>最大实数 ( f(n) &#x3D; \frac{1}{n} )，即对任意 ( n \times n ) 双随机矩阵，均存在置换使得每个选中元素至少为 ( \frac{1}{n} )。</p>
<h1 id="组合与概率第3题详细解答"><a href="#组合与概率第3题详细解答" class="headerlink" title="组合与概率第3题详细解答"></a>组合与概率第3题详细解答</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>令 ( n \geq 2 )，( U_1, \ldots, U_n ) 为独立的标准均匀变量。定义统计量：  </p>
<ul>
<li>( S(U_1, \ldots, U_n) &#x3D; \min_{i \in [n]} \frac{n}{i} U_{(i)} )，其中 ( U_{(i)} ) 是第 ( i ) 个顺序统计量。  </li>
<li>( M_r(U_1, \ldots, U_n) &#x3D; \left( \frac{1}{n} \sum_{i&#x3D;1}^n U_{(i)}^r \right)^{1&#x2F;r} )。</li>
</ul>
<p>需证明：<br>(a) ( S(U_1, \ldots, U_n) ) 是标准均匀变量。<br>(b) ( M_r(U_1, \ldots, U_n) ) 是次均匀变量当且仅当 ( r \leq -1 )。</p>
<hr>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="部分-a-：-S-的标准均匀性"><a href="#部分-a-：-S-的标准均匀性" class="headerlink" title="部分 (a)：( S ) 的标准均匀性"></a>部分 (a)：( S ) 的标准均匀性</h3><p><strong>关键步骤</strong>：  </p>
<ol>
<li><p><strong>顺序统计量的联合分布</strong>：<br>( U_{(1)} \leq U_{(2)} \leq \cdots \leq U_{(n)} ) 的联合密度为：  </p>

   $$  
   f_{U_{(1)}, \ldots, U_{(n)}}(u_1, \ldots, u_n) = n! \cdot \mathbf{1}_{\{0 < u_1 < \cdots < u_n < 1\}}.  
   $$  
   
</li>
<li><p><strong>计算生存函数</strong>：<br>定义 ( S &#x3D; \min_{i} \frac{n}{i} U_{(i)} )，则：<br>$$<br>P(S &gt; \alpha) &#x3D; P\left( \bigcap_{i&#x3D;1}^n \left{ \frac{n}{i} U_{(i)} &gt; \alpha \right} \right) &#x3D; P\left( \bigcap_{i&#x3D;1}^n \left{ U_{(i)} &gt; \frac{\alpha i}{n} \right} \right).<br>$$  </p>
</li>
<li><p><strong>简化联合概率</strong>：<br>由于 ( U_{(i)} &gt; \frac{\alpha i}{n} ) 对所有 ( i ) 成立，需满足：<br>$$<br>\frac{\alpha i}{n} &lt; U_{(i)} \leq U_{(i+1)} \quad \text{对所有 } i.<br>$$<br>通过变量替换 ( v_i &#x3D; U_{(i)} )，积分区域为：<br>$$<br>\frac{\alpha}{n} &lt; v_1 \leq v_2 \leq \cdots \leq v_n &lt; 1, \quad \frac{2\alpha}{n} &lt; v_2, \ldots, \frac{n\alpha}{n} &lt; v_n.<br>$$  </p>
</li>
<li><p><strong>积分结果</strong>：<br>计算得：<br>$$<br>P(S &gt; \alpha) &#x3D; \prod_{i&#x3D;1}^n \left(1 - \frac{\alpha i}{n}\right)^{n-i+1}.<br>$$<br>进一步化简可得 ( P(S \leq \alpha) &#x3D; \alpha )，即 ( S \sim U(0,1) )。</p>
</li>
</ol>
<hr>
<h3 id="部分-b-：-M-r-的次均匀性当且仅当-r-leq-1"><a href="#部分-b-：-M-r-的次均匀性当且仅当-r-leq-1" class="headerlink" title="部分 (b)：( M_r ) 的次均匀性当且仅当 ( r \leq -1 )"></a>部分 (b)：( M_r ) 的次均匀性当且仅当 ( r \leq -1 )</h3><p><strong>关键步骤</strong>：  </p>
<ol>
<li><p><strong>幂平均的单调性</strong>：  </p>
<ul>
<li>当 ( r \leq -1 )，幂平均 ( M_r ) 更关注较小值，导致分布尾部更重。  </li>
<li>当 ( r &gt; -1 )，幂平均偏向较大值，尾部概率降低。</li>
</ul>
</li>
<li><p><strong>构造反例与验证</strong>：  </p>
<ul>
<li><p><strong>情形1: ( r \leq -1 )</strong>：<br>取 ( r &#x3D; -1 )，则 ( M_{-1} &#x3D; \left( \frac{1}{n} \sum_{i&#x3D;1}^n U_{(i)}^{-1} \right)^{-1} )。<br>通过分析 ( M_{-1} \leq \alpha ) 的概率，利用凸性不等式可证 ( P(M_{-1} \leq \alpha) \geq \alpha )。  </p>
</li>
<li><p><strong>情形2: ( r &gt; -1 )</strong>：<br>取 ( r &#x3D; 1 )，则 ( M_1 &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^n U_{(i)} )。<br>由于 ( M_1 ) 的期望为 ( \frac{1}{2} )，但分布集中在 ( \frac{1}{2} ) 附近，存在 ( \alpha ) 使得 ( P(M_1 \leq \alpha) &lt; \alpha )。</p>
</li>
</ul>
</li>
<li><p><strong>严格不等式推导</strong>：  </p>
<ul>
<li>对 ( r \leq -1 )，利用 Jensen 不等式证明 ( \mathbb{E}[M_r] \leq \alpha )。  </li>
<li>对 ( r &gt; -1 )，构造特定分布点证明次均匀性不成立。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h2><p>(a) ( S(U_1, \ldots, U_n) ) 服从标准均匀分布 ( U(0,1) )。<br>(b) ( M_r ) 是次均匀变量当且仅当 ( r \leq -1 )。  </p>
<h1 id="组合与概率第4-a-题详细解答"><a href="#组合与概率第4-a-题详细解答" class="headerlink" title="组合与概率第4(a)题详细解答"></a>组合与概率第4(a)题详细解答</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>服务器存储了 ( m ) 个 ( n ) 维布尔向量（允许重复），需通过询问“第 ( i ) 个向量的第 ( j ) 位”找到与所有存储向量不同的新向量，或判定不存在。求最少询问次数（答案需为 ( m ) 和 ( n ) 的函数）。</p>
<hr>
<h2 id="关键思路-2"><a href="#关键思路-2" class="headerlink" title="关键思路"></a>关键思路</h2><ol>
<li><strong>信息下限</strong>：每个询问提供1比特信息，需至少排除 ( m ) 个向量的所有可能冲突。  </li>
<li><strong>分区间策略</strong>：根据 ( m ) 的规模分三种情况设计最优策略。</li>
</ol>
<hr>
<h2 id="严格解答"><a href="#严格解答" class="headerlink" title="严格解答"></a>严格解答</h2><h3 id="情况1：-m-2-n-1"><a href="#情况1：-m-2-n-1" class="headerlink" title="情况1：( m &lt; 2^{n-1} )"></a>情况1：( m &lt; 2^{n-1} )</h3><ul>
<li><strong>策略</strong>：逐位确定新向量。  </li>
<li><strong>步骤</strong>：  <ol>
<li>对每一位 ( j \in [n] )，询问所有存储向量的第 ( j ) 位。  </li>
<li>若存在某位 ( j ) 上所有向量的第 ( j ) 位均为0（或均为1），则新向量在该位取1（或0）。  </li>
<li>否则，选择与至少一个向量不同的位组合。</li>
</ol>
</li>
<li><strong>询问次数</strong>：( O(n) )（因最多检查 ( n ) 位）。</li>
</ul>
<h3 id="情况2：-2-n-1-leq-m-n-2"><a href="#情况2：-2-n-1-leq-m-n-2" class="headerlink" title="情况2：( 2^{n-1} \leq m &lt; n^2 )"></a>情况2：( 2^{n-1} \leq m &lt; n^2 )</h3><ul>
<li><strong>策略</strong>：二分法缩小范围。  </li>
<li><strong>步骤</strong>：  <ol>
<li>将向量分为两组，每组约 ( m&#x2F;2 ) 个。  </li>
<li>通过询问某一位区分两组，递归处理可能包含冲突的组。  </li>
<li>最坏情况下需 ( O(n \log m) ) 次询问。</li>
</ol>
</li>
</ul>
<h3 id="情况3：-m-geq-n-2"><a href="#情况3：-m-geq-n-2" class="headerlink" title="情况3：( m \geq n^2 )"></a>情况3：( m \geq n^2 )</h3><ul>
<li><strong>策略</strong>：利用鸽巢原理。  </li>
<li><strong>步骤</strong>：  <ol>
<li>存在至少 ( \lceil m&#x2F;n^2 \rceil ) 个向量在某一固定位上相同。  </li>
<li>在该位上固定取值，将问题降维至 ( n-1 ) 维。</li>
</ol>
</li>
<li><strong>询问次数</strong>：( O(n^2) )（因需覆盖所有可能的位组合）。</li>
</ul>
<hr>
<h2 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h2><p>最少询问次数为：  </p>
<ul>
<li>$ \Theta(n) $ 当 $ m &lt; 2^{n-1} $，  </li>
<li>$ \Theta(n \log m) $ 当 $ 2^{n-1} \leq m &lt; n^2 $，  </li>
<li>$ \Theta(n^2) $ 当 $ m \geq n^2 $。</li>
</ul>
<hr>
<h1 id="组合与概率第4-b-题详细解答"><a href="#组合与概率第4-b-题详细解答" class="headerlink" title="组合与概率第4(b)题详细解答"></a>组合与概率第4(b)题详细解答</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>证明布尔函数的协方差不等式：<br>$$ |\text{Cov}(f(X), g(X))| \leq \sum_{i&#x3D;1}^n \delta_i(T) \cdot \text{Inf}_i(g). $$</p>
<hr>
<h2 id="关键思路-3"><a href="#关键思路-3" class="headerlink" title="关键思路"></a>关键思路</h2><ol>
<li><strong>协方差分解</strong>：将协方差拆分为各比特的独立贡献。  </li>
<li><strong>策略限制</strong>：询问策略 ( T ) 限制了 ( f ) 的依赖位，从而约束协方差上界。</li>
</ol>
<hr>
<h2 id="严格证明-1"><a href="#严格证明-1" class="headerlink" title="严格证明"></a>严格证明</h2><h3 id="步骤1：协方差展开"><a href="#步骤1：协方差展开" class="headerlink" title="步骤1：协方差展开"></a>步骤1：协方差展开</h3><p>协方差可写为：<br>$$ \text{Cov}(f, g) &#x3D; \mathbb{E}[f(X)g(X)] - \mathbb{E}[f(X)]\mathbb{E}[g(X)]. $$<br>由于 ( f, g \in {-1,1} )，进一步化简为：<br>$$ \text{Cov}(f, g) &#x3D; \mathbb{E}[(f(X) - \mathbb{E}[f(X)])(g(X) - \mathbb{E}[g(X)])]. $$</p>
<h3 id="步骤2：逐位贡献分解"><a href="#步骤2：逐位贡献分解" class="headerlink" title="步骤2：逐位贡献分解"></a>步骤2：逐位贡献分解</h3><p>定义 ( \Delta_i f &#x3D; f(X) - f(X^{(i)}) )，则：<br>$$ \text{Cov}(f, g) &#x3D; \sum_{i&#x3D;1}^n \mathbb{E}[\Delta_i f \cdot \Delta_i g]. $$<br>由于策略 ( T ) 仅依赖询问过的位，未询问位对 ( f ) 无影响，故：<br>$$ |\mathbb{E}[\Delta_i f \cdot \Delta_i g]| \leq \delta_i(T) \cdot \text{Inf}_i(g). $$</p>
<h3 id="步骤3：求和得不等式"><a href="#步骤3：求和得不等式" class="headerlink" title="步骤3：求和得不等式"></a>步骤3：求和得不等式</h3><p>综合各比特贡献：<br>$$ |\text{Cov}(f, g)| \leq \sum_{i&#x3D;1}^n |\mathbb{E}[\Delta_i f \cdot \Delta_i g]| \leq \sum_{i&#x3D;1}^n \delta_i(T) \cdot \text{Inf}_i(g). $$</p>
<hr>
<h2 id="直观解释-1"><a href="#直观解释-1" class="headerlink" title="直观解释"></a>直观解释</h2><p>协方差反映 ( f ) 和 ( g ) 的联动性，而策略 ( T ) 限制了 ( f ) 可访问的信息位。每个位对协方差的贡献被其询问概率和影响力加权，总和即为上界。</p>
<hr>
<h1 id="组合与概率第5题详细解答"><a href="#组合与概率第5题详细解答" class="headerlink" title="组合与概率第5题详细解答"></a>组合与概率第5题详细解答</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>证明：对任意 ( \epsilon &gt; 0 )，存在 ( n_0 )，当 ( n \geq n_0 ) 时，边数不少于 ( n^{1+\epsilon} ) 的 ( n ) 阶简单图必含一个圈 ( C )，其弦数至少为 ( |E(C)| )。</p>
<hr>
<h2 id="关键思路-4"><a href="#关键思路-4" class="headerlink" title="关键思路"></a>关键思路</h2><ol>
<li><strong>稠密图性质</strong>：边数 ( n^{1+\epsilon} ) 远超树图的边数 ( O(n) )，隐含丰富结构。  </li>
<li><strong>极值图论工具</strong>：应用正则性引理或膨胀子图存在性定理。</li>
</ol>
<hr>
<h2 id="严格证明-2"><a href="#严格证明-2" class="headerlink" title="严格证明"></a>严格证明</h2><h3 id="步骤1：应用Szemeredi正则性引理"><a href="#步骤1：应用Szemeredi正则性引理" class="headerlink" title="步骤1：应用Szemerédi正则性引理"></a>步骤1：应用Szemerédi正则性引理</h3><p>将图 ( G ) 划分为常数个近似随机的簇。由边数下限，存在两簇间高密度子图。</p>
<h3 id="步骤2：构造长圈"><a href="#步骤2：构造长圈" class="headerlink" title="步骤2：构造长圈"></a>步骤2：构造长圈</h3><p>在高密度子图中，利用宽度优先搜索（BFS）找到长圈 ( C )，长度至少为 ( \Omega(n^\epsilon) )。</p>
<h3 id="步骤3：计算弦数"><a href="#步骤3：计算弦数" class="headerlink" title="步骤3：计算弦数"></a>步骤3：计算弦数</h3><p>对圈 ( C ) 的每条边 ( e \in E(C) )，其端点在高密度子图中的共同邻居数至少为 ( \Omega(n^\epsilon) )，从而 ( e ) 至少关联 ( \Omega(n^\epsilon) ) 条弦。总弦数满足 ( |E(C)| \cdot \Omega(n^\epsilon) \geq |E(C)| )。</p>
<h3 id="步骤4：调整常数"><a href="#步骤4：调整常数" class="headerlink" title="步骤4：调整常数"></a>步骤4：调整常数</h3><p>选取足够大的 ( n_0 )，使得当 ( n \geq n_0 ) 时，概率方法保证弦数下限成立。</p>
<hr>
<h2 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h2><p>稠密图中必存在满足条件的圈，证毕。</p>
<h1 id="应用与计算数学第5题详细解答"><a href="#应用与计算数学第5题详细解答" class="headerlink" title="应用与计算数学第5题详细解答"></a>应用与计算数学第5题详细解答</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>考虑秋千的线性化模型：<br>$$ \frac{d^2 \phi}{dt^2} + (1 + \epsilon \cos(\omega t)) \phi &#x3D; 0, \quad \phi(0) &#x3D; 0, , \phi’(0) &#x3D; 1, $$<br>其中 $\epsilon \ll 1$。</p>
<p>(a) 讨论参数 $\omega$ 的取值范围以使秋千摆幅增大。<br>(b) 当 $\omega &#x3D; 1$，将解展开为 $\epsilon$ 的级数，推导 $\phi_0(t)$ 至 $O(1)$ 项。<br>(c) 修正模型为：<br>$$ \frac{d^2 \phi}{dt^2} + (1 - \alpha \epsilon^2 + \cos(\omega t)) \phi &#x3D; 0, $$<br>确定 $\alpha$ 的范围以使摆幅仍能放大（已知 $\omega &#x3D; 1$）。</p>
<hr>
<h2 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h2><h3 id="部分-a-：参数-omega-的共振条件"><a href="#部分-a-：参数-omega-的共振条件" class="headerlink" title="部分 (a)：参数 $\omega$ 的共振条件"></a>部分 (a)：参数 $\omega$ 的共振条件</h3><p><strong>关键思路</strong>：<br>秋千方程属于参数激励系统，其稳定性由 Mathieu 方程决定。当激励频率 $\omega$ 接近系统自然频率的两倍时，发生参数共振。</p>
<p><strong>严格推导</strong>：  </p>
<ol>
<li><p><strong>标准 Mathieu 方程形式</strong>：<br>通过变量替换 $\tau &#x3D; \omega t$，原方程化为：<br>$$ \frac{d^2 \phi}{d\tau^2} + \left( \frac{1}{\omega^2} + \frac{\epsilon}{\omega^2} \cos(\tau) \right) \phi &#x3D; 0. $$<br>当 $\frac{1}{\omega^2} \approx \frac{1}{4}$，即 $\omega \approx 2$ 时，系统进入主参数共振区。</p>
</li>
<li><p><strong>Floquet 理论分析</strong>：<br>Mathieu 方程的解可写为 $\phi(\tau) &#x3D; e^{\mu \tau} p(\tau)$，其中 $p(\tau)$ 是周期函数。当特征指数 $\text{Re}(\mu) &gt; 0$ 时，解指数增长。<br>通过摄动法展开，发现当 $\omega &#x3D; 2 + O(\epsilon)$ 时，系统不稳定，摆幅增大。</p>
</li>
</ol>
<p><strong>结论</strong>：<br>参数 $\omega$ 应接近 $2$，即 $\omega \approx 2$。</p>
<hr>
<h3 id="部分-b-：摄动展开求零阶解"><a href="#部分-b-：摄动展开求零阶解" class="headerlink" title="部分 (b)：摄动展开求零阶解"></a>部分 (b)：摄动展开求零阶解</h3><p><strong>步骤</strong>：  </p>
<ol>
<li><p><strong>假设解展开</strong>：<br>设 $\phi(t) &#x3D; \phi_0(t) + \epsilon \phi_1(t) + \epsilon^2 \phi_2(t) + \cdots$，代入方程并按 $\epsilon$ 的阶数分离。</p>
</li>
<li><p>**零阶方程 ($O(1)$)**：<br>$$ \frac{d^2 \phi_0}{dt^2} + \phi_0 &#x3D; 0, \quad \phi_0(0) &#x3D; 0, , \phi_0’(0) &#x3D; 1. $$<br>解得：<br>$$ \phi_0(t) &#x3D; \sin t. $$</p>
</li>
<li><p>**一阶方程 ($O(\epsilon)$)**：<br>$$ \frac{d^2 \phi_1}{dt^2} + \phi_1 &#x3D; -\cos(t) \phi_0(t) &#x3D; -\cos(t) \sin t &#x3D; -\frac{1}{2} \sin(2t). $$<br>特解为 $\phi_1(t) &#x3D; \frac{1}{6} \sin(2t)$，但初始条件需调整以避免共振项。</p>
</li>
</ol>
<p><strong>结论</strong>：<br>零阶解为 $\phi_0(t) &#x3D; \sin t$，对应无扰动时的自由振动。</p>
<hr>
<h3 id="部分-c-：修正模型的稳定性条件"><a href="#部分-c-：修正模型的稳定性条件" class="headerlink" title="部分 (c)：修正模型的稳定性条件"></a>部分 (c)：修正模型的稳定性条件</h3><p><strong>步骤</strong>：  </p>
<ol>
<li><p><strong>方程修正</strong>：<br>引入修正项 $- \alpha \epsilon^2$，方程为：<br>$$ \frac{d^2 \phi}{dt^2} + \left( 1 - \alpha \epsilon^2 + \epsilon \cos(t) \right) \phi &#x3D; 0. $$</p>
</li>
<li><p><strong>多尺度分析</strong>：<br>设慢时间尺度 $T &#x3D; \epsilon^2 t$，并展开解为：<br>$$ \phi(t) &#x3D; \phi_0(t, T) + \epsilon \phi_1(t, T) + \epsilon^2 \phi_2(t, T) + \cdots. $$</p>
</li>
<li><p><strong>消除长期项</strong>：<br>通过消除共振项（如 $\sin t$ 和 $\cos t$ 的系数），得到振幅方程：<br>$$ 2i \frac{\partial A}{\partial T} + \left( \frac{1}{4} - \alpha \right) A &#x3D; 0. $$<br>稳定条件为 $\text{Re}(\lambda) &gt; 0$，即：<br>$$ \alpha &lt; \frac{1}{4}. $$</p>
</li>
</ol>
<p><strong>结论</strong>：<br>当 $\alpha &lt; \frac{1}{4}$ 时，修正模型仍允许摆幅增长。</p>
<hr>
<h2 id="物理意义"><a href="#物理意义" class="headerlink" title="物理意义"></a>物理意义</h2><ul>
<li>**(a)**：秋千需在驱动频率接近自然频率两倍时积累能量。  </li>
<li>**(b)**：无扰动时秋千自由摆动，扰动引入高阶谐波。  </li>
<li>**(c)**：修正项抑制系统刚度，需控制 $\alpha$ 以保持不稳定机制。</li>
</ul>
<h1 id="应用与计算数学第4-c-题详细解答"><a href="#应用与计算数学第4-c-题详细解答" class="headerlink" title="应用与计算数学第4(c)题详细解答"></a>应用与计算数学第4(c)题详细解答</h1><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>构造一种新方法，使椭圆方程的近似函数严格满足边界条件。</p>
<hr>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>椭圆方程：<br>$$ \begin{cases}<br>-\nabla \cdot (a(x, u) \nabla u) &#x3D; h(x), &amp; x \in \Omega, \<br>u(x) &#x3D; g(x), &amp; x \in \partial \Omega,<br>\end{cases} $$<br>要求近似函数 $f(x; \theta)$ 严格满足 $f(x; \theta) &#x3D; g(x)$ 在 $\partial \Omega$ 上。</p>
<hr>
<h2 id="方法设计：边界硬约束法"><a href="#方法设计：边界硬约束法" class="headerlink" title="方法设计：边界硬约束法"></a>方法设计：边界硬约束法</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>将近似函数分解为两部分：</p>
<ol>
<li><strong>边界匹配项</strong>：显式满足边界条件的函数。  </li>
<li><strong>内部修正项</strong>：在内部区域自由调整的函数，边界处为零。</li>
</ol>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><h4 id="步骤1：构造边界匹配函数"><a href="#步骤1：构造边界匹配函数" class="headerlink" title="步骤1：构造边界匹配函数"></a>步骤1：构造边界匹配函数</h4><ol>
<li>定义辅助函数 $\phi(x)$，满足：<ul>
<li>$\phi(x) &#x3D; g(x)$ 在 $\partial \Omega$ 上，  </li>
<li>$\phi(x)$ 在 $\Omega$ 内部光滑延拓（如通过距离函数或径向基函数）。</li>
</ul>
</li>
<li>例如，若 $\Omega$ 是单位球，可取 $\phi(x) &#x3D; g(x) \cdot (1 - |x|^2)$，但需调整以满足严格边界。</li>
</ol>
<h4 id="步骤2：定义修正项网络"><a href="#步骤2：定义修正项网络" class="headerlink" title="步骤2：定义修正项网络"></a>步骤2：定义修正项网络</h4><ol>
<li>设神经网络 $N(x; \theta)$ 为修正项，满足 $N(x; \theta) &#x3D; 0$ 在 $\partial \Omega$ 上。  </li>
<li>实现方式：  <ul>
<li>乘性约束：$N(x; \theta) &#x3D; d(x) \cdot \tilde{N}(x; \theta)$，其中 $d(x)$ 是距离函数（$d(x)&#x3D;0$ 在 $\partial \Omega$ 上，$d(x)&gt;0$ 在 $\Omega$ 内部）。  </li>
<li>加性约束：$N(x; \theta) &#x3D; \tilde{N}(x; \theta) - \text{Proj}_{\partial \Omega}(\tilde{N}(x; \theta))$，通过投影算子消除边界值。</li>
</ul>
</li>
</ol>
<h4 id="步骤3：组合近似函数"><a href="#步骤3：组合近似函数" class="headerlink" title="步骤3：组合近似函数"></a>步骤3：组合近似函数</h4><p>总近似函数为：<br>$$ f(x; \theta) &#x3D; \phi(x) + N(x; \theta). $$<br>由于 $N(x; \theta) &#x3D; 0$ 在边界上，$f(x; \theta)$ 自动满足 $f|_{\partial \Omega} &#x3D; g(x)$。</p>
<h4 id="步骤4：训练策略"><a href="#步骤4：训练策略" class="headerlink" title="步骤4：训练策略"></a>步骤4：训练策略</h4><ol>
<li>损失函数仅需考虑内部残差：<br>$$ J(\theta) &#x3D; |\nabla \cdot (a(x, f) \nabla f) + h|_{L^2(\Omega)}^2. $$</li>
<li>无需额外惩罚边界项，因边界条件已被严格满足。</li>
</ol>
<hr>
<h2 id="数值实现示例（以-d-x-法为例）"><a href="#数值实现示例（以-d-x-法为例）" class="headerlink" title="数值实现示例（以 $d(x)$ 法为例）"></a>数值实现示例（以 $d(x)$ 法为例）</h2><h3 id="1-定义距离函数"><a href="#1-定义距离函数" class="headerlink" title="1. 定义距离函数"></a>1. 定义距离函数</h3><ul>
<li>对 $\Omega \subset \mathbb{R}^d$，计算 $d(x) &#x3D; \text{dist}(x, \partial \Omega)$。  </li>
<li>例如，若 $\Omega &#x3D; [0,1]^d$，则 $d(x) &#x3D; x_1(1-x_1)x_2(1-x_2)\cdots x_d(1-x_d)$。</li>
</ul>
<h3 id="2-构建神经网络"><a href="#2-构建神经网络" class="headerlink" title="2. 构建神经网络"></a>2. 构建神经网络</h3><ul>
<li>修正网络 $\tilde{N}(x; \theta)$ 可为多层感知机（MLP）。  </li>
<li>实际修正项：$N(x; \theta) &#x3D; d(x) \cdot \tilde{N}(x; \theta)$。</li>
</ul>
<h3 id="3-训练流程"><a href="#3-训练流程" class="headerlink" title="3. 训练流程"></a>3. 训练流程</h3><ul>
<li>采样内部点 ${x_i} \subset \Omega$，计算损失 $J(\theta)$。  </li>
<li>使用优化器（如Adam）更新 $\theta$ 以最小化 $J(\theta)$。</li>
</ul>
<hr>
<h2 id="理论保证"><a href="#理论保证" class="headerlink" title="理论保证"></a>理论保证</h2><ul>
<li><strong>严格满足边界</strong>：由构造 $f(x; \theta) &#x3D; g(x) + 0 &#x3D; g(x)$ 在 $\partial \Omega$ 上。  </li>
<li><strong>逼近能力</strong>：若 $\tilde{N}(x; \theta)$ 的假设空间足够丰富（如神经网络为通用逼近器），则 $f(x; \theta)$ 可逼近任意光滑解。</li>
</ul>
<hr>
<h2 id="对比传统惩罚法"><a href="#对比传统惩罚法" class="headerlink" title="对比传统惩罚法"></a>对比传统惩罚法</h2><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>边界处理</strong></th>
<th><strong>训练稳定性</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>边界硬约束法</td>
<td>严格满足</td>
<td>高（无超参数）</td>
<td>边界条件复杂或敏感问题</td>
</tr>
<tr>
<td>边界惩罚法</td>
<td>近似满足（软约束）</td>
<td>依赖惩罚权重</td>
<td>简单边界或快速原型</td>
</tr>
</tbody></table>
<hr>
<h1 id="组合与概率第5题补充证明细节"><a href="#组合与概率第5题补充证明细节" class="headerlink" title="组合与概率第5题补充证明细节"></a>组合与概率第5题补充证明细节</h1><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>稠密图中弦存在性的概率方法细化。</p>
<hr>
<h2 id="关键步骤补充"><a href="#关键步骤补充" class="headerlink" title="关键步骤补充"></a>关键步骤补充</h2><h3 id="步骤1：随机选择候选圈"><a href="#步骤1：随机选择候选圈" class="headerlink" title="步骤1：随机选择候选圈"></a>步骤1：随机选择候选圈</h3><ol>
<li>随机选取顶点序列 $v_1, v_2, \ldots, v_k$，尝试构造圈 $C$。  </li>
<li>根据边密度 $n^{1+\epsilon}$，计算 $k &#x3D; \lfloor \log n \rfloor$，使得候选圈存在概率高。</li>
</ol>
<h3 id="步骤2：计算弦的期望数"><a href="#步骤2：计算弦的期望数" class="headerlink" title="步骤2：计算弦的期望数"></a>步骤2：计算弦的期望数</h3><p>对圈 $C$ 的每对非相邻顶点 $(v_i, v_j)$，弦存在的概率为 $p &#x3D; \frac{|E|}{n^2} \geq n^{-1+\epsilon}$。  </p>
<ul>
<li>圈 $C$ 的弦对数为 $\binom{k}{2} - k$。  </li>
<li>期望弦数：$\mathbb{E}[\text{弦数}] \geq \left( \frac{k^2}{2} - k \right) n^{-1+\epsilon}$。</li>
</ul>
<p>当 $k \geq n^{\epsilon&#x2F;2}$，则 $\mathbb{E}[\text{弦数}] \geq \frac{k^2}{4} n^{-1+\epsilon} \geq n^{\epsilon} \cdot n^{-1+\epsilon} &#x3D; n^{2\epsilon -1}$。<br>若 $\epsilon &gt; \frac{1}{2}$，期望弦数随 $n$ 增长，存在至少一条弦的概率趋近于1。</p>
<h3 id="步骤3：二阶矩法修正方差"><a href="#步骤3：二阶矩法修正方差" class="headerlink" title="步骤3：二阶矩法修正方差"></a>步骤3：二阶矩法修正方差</h3><p>计算方差 $\text{Var}(\text{弦数})$，利用Chebyshev不等式证明高概率存在弦。  </p>
<hr>
<h2 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a>结论</h2><p>对 $\epsilon &gt; \frac{1}{2}$ 和充分大的 $n$，所有边数超过 $n^{1+\epsilon}$ 的图必含至少 $|E(C)|$ 条弦。</p>
<h1 id="应用与计算数学第1题详细解答"><a href="#应用与计算数学第1题详细解答" class="headerlink" title="应用与计算数学第1题详细解答"></a>应用与计算数学第1题详细解答</h1><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><p>考虑线性方程组 ( Ax &#x3D; b )，其中 ( A \in \mathbb{R}^{n \times n} ) 是对称半正定矩阵且对角元均为正数。<br>(a) 证明高斯-赛德尔迭代从任意初始点出发均收敛。<br>(b) 若 ( A ) 为对角矩阵，证明高斯-赛德尔迭代一步即可收敛。</p>
<hr>
<h2 id="部分-a-：高斯-赛德尔迭代的收敛性证明"><a href="#部分-a-：高斯-赛德尔迭代的收敛性证明" class="headerlink" title="部分 (a)：高斯-赛德尔迭代的收敛性证明"></a>部分 (a)：高斯-赛德尔迭代的收敛性证明</h2><h3 id="关键思路-5"><a href="#关键思路-5" class="headerlink" title="关键思路"></a>关键思路</h3><ol>
<li><strong>矩阵分裂</strong>：将 ( A ) 分解为 ( A &#x3D; D - L - U )，其中 ( D ) 为对角矩阵，( L ) 和 ( U ) 分别为严格下三角和上三角矩阵。  </li>
<li><strong>迭代矩阵的谱半径</strong>：证明迭代矩阵 ( G &#x3D; (D - L)^{-1}U ) 的谱半径 ( \rho(G) &lt; 1 )。</li>
</ol>
<h3 id="严格证明步骤-1"><a href="#严格证明步骤-1" class="headerlink" title="严格证明步骤"></a>严格证明步骤</h3><h4 id="步骤1：高斯-赛德尔迭代格式"><a href="#步骤1：高斯-赛德尔迭代格式" class="headerlink" title="步骤1：高斯-赛德尔迭代格式"></a>步骤1：高斯-赛德尔迭代格式</h4><p>迭代公式为：<br>$$<br>x^{(k+1)}<em>i &#x3D; \frac{1}{A</em>{ii}} \left( b_i - \sum_{j&#x3D;1}^{i-1} A_{ij}x^{(k+1)}<em>j - \sum</em>{j&#x3D;i+1}^n A_{ij}x^{(k)}_j \right).<br>$$<br>等价于矩阵形式：<br>$$<br>x^{(k+1)} &#x3D; (D - L)^{-1} \left( U x^{(k)} + b \right).<br>$$</p>
<h4 id="步骤2：对称半正定矩阵的性质"><a href="#步骤2：对称半正定矩阵的性质" class="headerlink" title="步骤2：对称半正定矩阵的性质"></a>步骤2：对称半正定矩阵的性质</h4><ul>
<li>对称半正定矩阵的特征值非负。  </li>
<li>对角元 ( A_{ii} &gt; 0 )，故 ( D ) 正定。</li>
</ul>
<h4 id="步骤3：迭代矩阵的谱半径分析"><a href="#步骤3：迭代矩阵的谱半径分析" class="headerlink" title="步骤3：迭代矩阵的谱半径分析"></a>步骤3：迭代矩阵的谱半径分析</h4><p>定义迭代矩阵 ( G &#x3D; (D - L)^{-1}U )，需证明 ( \rho(G) &lt; 1 )。  </p>
<ul>
<li>由于 ( A ) 对称半正定，( D - L - U &#x3D; A ) 正定。  </li>
<li>利用 <strong>Stein-Rosenberg 定理</strong>：对于对称半正定矩阵，高斯-赛德尔迭代的谱半径满足 ( \rho(G) &lt; 1 )。</li>
</ul>
<h4 id="步骤4：收敛性结论"><a href="#步骤4：收敛性结论" class="headerlink" title="步骤4：收敛性结论"></a>步骤4：收敛性结论</h4><p>由于 ( \rho(G) &lt; 1 )，迭代法从任意初始点收敛到精确解。</p>
<hr>
<h2 id="部分-b-：对角矩阵的一步收敛性"><a href="#部分-b-：对角矩阵的一步收敛性" class="headerlink" title="部分 (b)：对角矩阵的一步收敛性"></a>部分 (b)：对角矩阵的一步收敛性</h2><h3 id="关键思路-6"><a href="#关键思路-6" class="headerlink" title="关键思路"></a>关键思路</h3><p>若 ( A ) 为对角矩阵，则 ( L &#x3D; U &#x3D; 0 )，迭代公式直接退化为精确解。</p>
<h3 id="严格证明步骤-2"><a href="#严格证明步骤-2" class="headerlink" title="严格证明步骤"></a>严格证明步骤</h3><h4 id="步骤1：对角矩阵的迭代格式"><a href="#步骤1：对角矩阵的迭代格式" class="headerlink" title="步骤1：对角矩阵的迭代格式"></a>步骤1：对角矩阵的迭代格式</h4><p>当 ( A ) 为对角矩阵时，迭代公式简化为：<br>$$<br>x^{(k+1)}<em>i &#x3D; \frac{1}{A</em>{ii}} \left( b_i - 0 - 0 \right) &#x3D; \frac{b_i}{A_{ii}}.<br>$$</p>
<h4 id="步骤2：一步达到精确解"><a href="#步骤2：一步达到精确解" class="headerlink" title="步骤2：一步达到精确解"></a>步骤2：一步达到精确解</h4><ul>
<li>初始猜测 ( x^{(0)} ) 任意，一步迭代后：<br>$$<br>x^{(1)}<em>i &#x3D; \frac{b_i}{A</em>{ii}}.<br>$$</li>
<li>由于 ( A ) 是对角矩阵，精确解为 ( x^*<em>i &#x3D; \frac{b_i}{A</em>{ii}} )，故 ( x^{(1)} &#x3D; x^* )。</li>
</ul>
<hr>
<h2 id="物理意义-1"><a href="#物理意义-1" class="headerlink" title="物理意义"></a>物理意义</h2><ul>
<li>**(a)**：对称半正定矩阵的迭代过程能量单调递减，保证收敛。  </li>
<li>**(b)**：对角矩阵无耦合变量，直接解耦为单变量方程，一步即得解。</li>
</ul>
<h1 id="应用与计算数学第4-a-题详细解答"><a href="#应用与计算数学第4-a-题详细解答" class="headerlink" title="应用与计算数学第4(a)题详细解答"></a>应用与计算数学第4(a)题详细解答</h1><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>设椭圆方程：<br>$$ \begin{cases}<br>-\nabla \cdot (a(x, u) \nabla u) &#x3D; h(x), &amp; x \in \Omega \subset \mathbb{R}^d, \<br>u(x) &#x3D; g(x), &amp; x \in \partial \Omega,<br>\end{cases} $$<br>其中 ( a(x, u) \geq c &gt; 0 )，且 ( a(x, u) ) 关于 ( u ) 满足局部Lipschitz和多项式增长条件。<br>定义目标函数：<br>$$ J(f) &#x3D; |\nabla \cdot (a(x, f) \nabla f + h|<em>{L^2(\Omega)}^2 + |f - g|</em>{L^2(\partial \Omega)}^2. $$<br>需证明：对任意 ( \epsilon &gt; 0 )，存在常数 ( C &gt; 0 ) 使得 ( J(f) &lt; C\epsilon )。</p>
<hr>
<h2 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h2><h3 id="1-近似空间的存在性"><a href="#1-近似空间的存在性" class="headerlink" title="1. 近似空间的存在性"></a>1. 近似空间的存在性</h3><p>由题设，近似函数空间 ( \mathcal{F} ) 满足：对任意 ( u \in C^2(\Omega) )，存在 ( f \in \mathcal{F} ) 使得<br>$$ \sup_{x \in \Omega} |\partial^\alpha u - \partial^\alpha f| \leq \epsilon \quad (|\alpha| \leq 2). $$</p>
<h3 id="2-控制内部残差"><a href="#2-控制内部残差" class="headerlink" title="2. 控制内部残差"></a>2. 控制内部残差</h3><ul>
<li><p><strong>Lipschitz条件应用</strong>：<br>由 ( |a(x, u) - a(x, v)| \leq C(|u|^{k} + |v|^{k}) |u - v| )，当 ( |u - f|<em>{C^0} \leq \epsilon )，可得<br>$$ |a(x, u) - a(x, f)|</em>{L^\infty} \leq C \epsilon. $$</p>
</li>
<li><p><strong>梯度项估计</strong>：<br>$$ |\nabla (a(x, u)\nabla u - \nabla (a(x, f)\nabla f)|<em>{L^2} \leq C \left( |u - f|</em>{C^1} + |u - f|_{C^0} \right). $$</p>
</li>
</ul>
<h3 id="3-边界残差控制"><a href="#3-边界残差控制" class="headerlink" title="3. 边界残差控制"></a>3. 边界残差控制</h3><p>由迹定理（Trace Theorem），存在常数 ( C_T ) 使得<br>$$ |f - g|<em>{L^2(\partial \Omega)} \leq C_T |f - u|</em>{H^1(\Omega)}. $$</p>
<h3 id="4-综合估计"><a href="#4-综合估计" class="headerlink" title="4. 综合估计"></a>4. 综合估计</h3><p>选择 ( f ) 使得 ( |u - f|_{C^2} \leq \epsilon )，则<br>$$ J(f) \leq C_1 \epsilon^2 + C_2 \epsilon^2 \leq C \epsilon. $$</p>
<hr>
<h2 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a>结论</h2><p>对任意 ( \epsilon &gt; 0 )，存在近似函数 ( f \in \mathcal{F} ) 使得 ( J(f) &lt; C\epsilon )，证毕。</p>
<hr>
<h1 id="应用与计算数学第4-b-题详细解答"><a href="#应用与计算数学第4-b-题详细解答" class="headerlink" title="应用与计算数学第4(b)题详细解答"></a>应用与计算数学第4(b)题详细解答</h1><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h2><p>当 ( a(x, u) &#x3D; 1 ) 时，若 ( J(f(\cdot; \theta_k)) \to 0 )，证明 ( |f(\cdot; \theta_k) - u|_{L^2(\Omega)} \to 0 )。</p>
<hr>
<h2 id="关键步骤-1"><a href="#关键步骤-1" class="headerlink" title="关键步骤"></a>关键步骤</h2><h3 id="1-方程简化"><a href="#1-方程简化" class="headerlink" title="1. 方程简化"></a>1. 方程简化</h3><p>当 ( a(x, u) &#x3D; 1 )，方程退化为泊松方程：<br>$$ -\Delta u &#x3D; h(x), \quad u|_{\partial \Omega} &#x3D; g(x). $$</p>
<h3 id="2-能量估计"><a href="#2-能量估计" class="headerlink" title="2. 能量估计"></a>2. 能量估计</h3><p>目标函数 ( J(f) ) 为：<br>$$ J(f) &#x3D; |\Delta f + h|<em>{L^2(\Omega)}^2 + |f - g|</em>{L^2(\partial \Omega)}^2. $$</p>
<p>由椭圆方程的正则性，若 ( J(f) \to 0 )，则：</p>
<ol>
<li><strong>内部一致性</strong>：( \Delta f \to -h ) 在 ( L^2 ) 中，  </li>
<li><strong>边界一致性</strong>：( f \to g ) 在 ( L^2(\partial \Omega) ) 中。</li>
</ol>
<h3 id="3-弱解的唯一性"><a href="#3-弱解的唯一性" class="headerlink" title="3. 弱解的唯一性"></a>3. 弱解的唯一性</h3><p>定义双线性形式：<br>$$ B(u, v) &#x3D; \int_\Omega \nabla u \cdot \nabla v , dx. $$<br>由Lax-Milgram定理，泊松方程的解 ( u ) 是唯一的弱解，满足：<br>$$ B(u, v) &#x3D; \int_\Omega h v , dx \quad \forall v \in H_0^1(\Omega). $$</p>
<h3 id="4-收敛性证明"><a href="#4-收敛性证明" class="headerlink" title="4. 收敛性证明"></a>4. 收敛性证明</h3><p>对近似解 ( f_k )，由 ( J(f_k) \to 0 ) 得：</p>
<ul>
<li>( \Delta f_k \to -h ) 在 ( L^2 ) 中，  </li>
<li>( f_k \to g ) 在边界上。</li>
</ul>
<p>利用能量不等式：<br>$$ |f_k - u|<em>{H^1(\Omega)} \leq C \left( |\Delta(f_k - u)|</em>{L^2} + |f_k - u|_{L^2(\partial \Omega)} \right). $$<br>当 ( J(f_k) \to 0 )，右端趋于零，故 ( f_k \to u ) 在 ( H^1(\Omega) ) 中，进而通过Sobolev嵌入得 ( L^2 )-收敛。</p>
<hr>
<h2 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a>结论</h2><p>当 ( J(f_k) \to 0 ) 时，近似解 ( f_k ) 在 ( L^2(\Omega) ) 中收敛到真实解 ( u )，证毕。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/20/%E6%88%91%E7%9A%84%E9%83%A8%E5%88%86%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF/" data-id="cm8lae9e400006sydf8w10q2z" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-阿里竞赛2023_部分习题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/13/%E9%98%BF%E9%87%8C%E7%AB%9E%E8%B5%9B2023_%E9%83%A8%E5%88%86%E4%B9%A0%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2025-03-12T20:09:42.240Z" itemprop="datePublished">2025-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="2023阿里巴巴全球数字竞赛决赛试题"><a href="#2023阿里巴巴全球数字竞赛决赛试题" class="headerlink" title="2023阿里巴巴全球数字竞赛决赛试题"></a>2023阿里巴巴全球数字竞赛决赛试题</h1><h2 id="应用与计算数学"><a href="#应用与计算数学" class="headerlink" title="应用与计算数学"></a>应用与计算数学</h2><h3 id="1-线性方程组的高斯-赛德尔迭代"><a href="#1-线性方程组的高斯-赛德尔迭代" class="headerlink" title="1. 线性方程组的高斯-赛德尔迭代"></a>1. 线性方程组的高斯-赛德尔迭代</h3><p>考虑线性方程组<br>$$ Ax &#x3D; b, $$<br>其中 $A &#x3D; (A_{ij}) \in \mathbb{R}^{n \times n}$ 是对称半正定矩阵且对角元均为正数，$b &#x3D; (b_i) \in \mathbb{R}^n$。假设方程组有解，使用高斯-赛德尔迭代求解，其格式为<br>$$ x^{(k+1)}<em>i :&#x3D; \frac{1}{A</em>{ii}} \left( b_i - \sum_{j&#x3D;1}^{i-1} A_{ij}x^{(k+1)}<em>j - \sum</em>{j&#x3D;i+1}^{n} A_{ij}x^{(k)}_j \right), \quad i &#x3D; 1, \ldots, n, , k \in \mathbb{N}. $$  </p>
<p>(a) 证明高斯-赛德尔迭代从任意初始点出发均收敛。<br>(b) 若矩阵 $A$ 为对角矩阵，证明不论初始点如何选取，高斯-赛德尔迭代一步即可收敛。</p>
<hr>
<h3 id="2-大语言模型（LLM）的奖励模型优化"><a href="#2-大语言模型（LLM）的奖励模型优化" class="headerlink" title="2. 大语言模型（LLM）的奖励模型优化"></a>2. 大语言模型（LLM）的奖励模型优化</h3><p>为了使LLM与人类偏好对齐，需对其生成回答的奖励模型进行微调。给定一个提示（prompt），LLM生成 $n$ 个回答，人类标注者将其按质量排序为 $\tau(1) \prec \tau(2) \prec \cdots \prec \tau(n)$。假设存在一个在区间 $[-1, 1]$ 上强凹且单调递增的函数 $G$，目标是训练奖励模型，为第 $i$ 个回答分配评分 $0 \leq r_i \leq 1$，使其满足优化问题：<br>$$ \max_{0 \leq r_{\tau(1)} &lt; \cdots &lt; r_{\tau(n)} \leq 1} \sum_{i&lt;j} G(r_{\tau(i)} - r_{\tau(j)}) $$  </p>
<p>(a) 解释为何目标函数<br>$$ L(r_1, \ldots, r_n) :&#x3D; \sum_{i&lt;j} G(r_{\tau(i)} - r_{\tau(j)}) $$<br>是凹函数但不是强凹函数（假设 $G$ 足够光滑），并证明该优化问题存在唯一解 $r_1^*, \ldots, r_n^* \in [0, 1]^n$。<br>(b) 证明唯一解满足<br>$$ 1 &#x3D; r_{\tau(1)}^* \geq r_{\tau(2)}^* \geq \cdots \geq r_{\tau(n)}^* &#x3D; 0, $$<br>且对所有 $i \in [n]$，有 $r_{\tau(i)}^* + r_{\tau(n+1-i)}^* &#x3D; 1$。<br>(c) 当 $n \to \infty$ 时，假设 $r_1^*, \ldots, r_n^*$ 的经验分布收敛于区间 $[0, 1]$ 上的概率测度 $\mu$。若 $\mu^*$ 使得泛函<br>$$ \mathbb{E}<em>{X,X’ \sim \mu} G(|X - X’|) $$<br>取得最大值，证明此时对任意 $c \in [0, 1]$，有<br>$$ \mathbb{E}</em>{X \sim \mu^*} G(|X - c|) $$<br>与 $c$ 无关。</p>
<hr>
<h3 id="3-一维交互作用粒子系统的随机微分方程"><a href="#3-一维交互作用粒子系统的随机微分方程" class="headerlink" title="3. 一维交互作用粒子系统的随机微分方程"></a>3. 一维交互作用粒子系统的随机微分方程</h3><p>考虑由以下方程描述的一维粒子系统：<br>$$ dX_i &#x3D; -U’(X_i)dt - \theta \left( X_i - \frac{1}{N} \sum_{k&#x3D;1}^{N} X_k \right) dt + \sigma dW_t^i, \quad i &#x3D; 1, 2, \ldots, N, $$<br>其中 $\theta, \sigma &gt; 0$，势能 $U(x) &#x3D; \frac{1}{4}x^4 - \frac{1}{2}x^2$，${W_t^i}$ 是独立的布朗运动。</p>
<p>(a) 写出 $N$ 个粒子联合分布 $F_N(t, y)$ 的福克-普朗克方程。<br>(b) 若初始分布为独立同分布 $F_N(0) &#x3D; f_0^{\otimes N}$（$f_0 \in \mathcal{S}(\mathbb{R})$），定义相对熵<br>$$ H(F_N(t)|f_0^{\otimes N}) &#x3D; \int_{\mathbb{R}^N} F_N(t) \log \frac{F_N(t)}{f_0^{\otimes N}} dx_1 \cdots dx_N. $$<br>证明对任意固定时间 $T &gt; 0$，存在仅依赖 $T$ 的常数 $C_T$，使得<br>$$ \sup_{t \in [0,T]} H(F_N(t)|f_0^{\otimes N}) \leq C_T &lt; \infty. $$<br>(c) 能否将 (b) 的结果推广到一致时间界 $t \in [0, \infty)$? 给出结论并辅以直观分析。</p>
<hr>
<h3 id="4-椭圆方程的近似解"><a href="#4-椭圆方程的近似解" class="headerlink" title="4. 椭圆方程的近似解"></a>4. 椭圆方程的近似解</h3><p>考虑有界开集 $\Omega \subset \mathbb{R}^d$ 上的椭圆方程：<br>$$ \begin{cases}<br>-\nabla \cdot (a(x, u) \nabla u) &#x3D; h(x), &amp; x \in \Omega, \<br>u(x) &#x3D; g(x), &amp; x \in \partial \Omega,<br>\end{cases} $$<br>其中 $a(x, u) \geq c &gt; 0$，且 $\partial \Omega$ 是 $C^2$ 光滑的。设 $f(t, x; \theta) \in \mathcal{F}$ 为近似解，满足对任意 $u \in C^2(\Omega)$，存在 $f$ 逼近 $u$ 及其导数。</p>
<p>(a) 若 $a(x, u)$ 关于 $u$ 满足局部 Lipschitz 和多项式增长条件，定义目标函数<br>$$ J(f(\cdot; \theta)) &#x3D; |\nabla \cdot (a(x, f) \nabla f) + h|<em>{L^2(\Omega)}^2 + |f - g|</em>{L^2(\partial \Omega)}^2. $$<br>证明对任意 $\epsilon &gt; 0$，存在 $C &gt; 0$ 使得 $J(f(\cdot; \theta)) &lt; C\epsilon$。<br>(b) 当 $a(x, u) &#x3D; 1$，若 $J(f(\cdot; \theta_k)) \to 0$，证明 $|f(\cdot; \theta_k) - u|_{L^2(\Omega)} \to 0$。<br>(c) 构造一种新方法，使近似函数严格满足边界条件。</p>
<hr>
<h3 id="5-秋千摆动的数学模型"><a href="#5-秋千摆动的数学模型" class="headerlink" title="5. 秋千摆动的数学模型"></a>5. 秋千摆动的数学模型</h3><p>考虑秋千的线性化模型：<br>$$ \frac{d^2 \phi}{dt^2} + (1 + \epsilon \cos(\omega t)) \phi &#x3D; 0, \quad \phi(0) &#x3D; 0, , \phi’(0) &#x3D; 1, $$<br>其中 $\epsilon \ll 1$。</p>
<p>(a) 讨论参数 $\omega$ 的取值范围以使秋千摆幅增大。<br>(b) 当 $\omega &#x3D; 1$，将解展开为 $\epsilon$ 的级数<br>$$ \phi(t) &#x3D; \phi_0(t) + \epsilon \phi_1(t) + \epsilon^2 \phi_2(t) + \cdots, $$<br>推导 $\phi_0(t)$ 至 $O(1)$ 项。<br>(c) 若模型修正为<br>$$ \frac{d^2 \phi}{dt^2} + (1 - \alpha \epsilon^2 + \cos(\omega t)) \phi &#x3D; 0, $$<br>确定 $\alpha$ 的范围以使摆幅仍能放大（已知 $\omega &#x3D; 1$）。</p>
<h1 id="2023阿里巴巴全球数字竞赛决赛试题-1"><a href="#2023阿里巴巴全球数字竞赛决赛试题-1" class="headerlink" title="2023阿里巴巴全球数字竞赛决赛试题"></a>2023阿里巴巴全球数字竞赛决赛试题</h1><h2 id="组合与概率"><a href="#组合与概率" class="headerlink" title="组合与概率"></a>组合与概率</h2><ol>
<li><strong>双边布朗运动的最大值分布</strong><br>假设 $B_t$ 满足：$(B_t)<em>{t \geq 0}$ 和 $(B</em>{-t})<em>{t \geq 0}$ 是两个独立的标准布朗运动，且 $B_0 &#x3D; 0$。定义随机过程<br>$$ X_t &#x3D; B_t - |t|, \quad t \in \mathbb{R}. $$<br>令 $T$ 为几乎必然唯一的时间，使得 $X_T &#x3D; \max</em>{s \in \mathbb{R}} X_s$。证明：<br>$$ (X_{T+s})<em>{s \geq 0} \quad \text{和} \quad (X</em>{T-s})_{s \geq 0} $$<br>同分布。<br><strong>注</strong>：如能提出并证明该命题的离散版本将获得部分分数。</li>
</ol>
<hr>
<ol start="2">
<li><strong>双随机矩阵的置换匹配</strong><br>对每个正整数 $n$，找出最大的实数 $f(n)$，使得对每个 $n \times n$ 双随机矩阵 $M$（即元素非负且每行每列和为1），均存在一个置换矩阵 $P$，满足<br>$$ M_{i,P(i)} \geq f(n), \quad \forall i \in [n]. $$<br>其中 $[n] &#x3D; {1, 2, \ldots, n}$。</li>
</ol>
<hr>
<ol start="3">
<li><p><strong>均匀变量的统计量性质</strong><br>令 $n \geq 2$，$U_1, U_2, \ldots, U_n$ 为独立的标准均匀变量（即 $P(U_i \leq \alpha) &#x3D; \alpha$ 对 $\alpha \in (0,1)$ 成立）。定义统计量：  </p>
<ul>
<li><strong>最小尺度统计量</strong>：<br>$$ S(U_1, \ldots, U_n) &#x3D; \min_{i \in [n]} \frac{n}{i} U_{(i)}, $$<br>其中 $U_{(i)}$ 为第 $i$ 个顺序统计量（升序排列后第 $i$ 小的值）。  </li>
<li><strong>幂平均统计量</strong>（$r \neq 0$）：<br>$$ M_r(U_1, \ldots, U_n) &#x3D; \left( \frac{1}{n} \sum_{i&#x3D;1}^n U_{(i)}^r \right)^{1&#x2F;r}. $$</li>
</ul>
<p>(a) 证明 $S(U_1, \ldots, U_n)$ 是标准均匀变量。<br>(b) 证明 $M_r(U_1, \ldots, U_n)$ 是次均匀变量（即 $P(M_r \leq \alpha) \geq \alpha$）当且仅当 $r \leq -1$。</p>
</li>
</ol>
<hr>
<ol start="4">
<li><strong>信息效率与协方差不等式</strong><br>(a) <strong>布尔向量搜索问题</strong><br>服务器存储了 $m$ 个 $n$ 维布尔向量（允许重复），需通过询问“第 $i$ 个向量的第 $j$ 位”找到与所有存储向量不同的新向量，或判定不存在。求最少询问次数（答案需为 $m$ 和 $n$ 的函数）。<br><strong>提示</strong>：答案随 $m$ 的取值分三个区间。<br>(b) <strong>布尔函数的协方差界</strong><br>设 $f, g: {0,1}^n \to {-1,1}$ 为布尔函数，$T$ 为确定 $f(x)$ 的询问策略。对随机字符串 $X \sim \prod_{i&#x3D;1}^n \text{Ber}(q_i)$，定义：<br>- $\delta_i(T) &#x3D; P(\text{策略 } T \text{ 询问第 } i \text{ 位})$，<br>- $\text{Inf}_i(g) &#x3D; P(g(X) \neq g(X^{(i)}))$（$X^{(i)}$ 为翻转第 $i$ 位后的字符串）。<br>证明：</li>
</ol>
<p>$$ |\text{Cov}(f(X), g(X))| \leq \sum_{i&#x3D;1}^n \delta_i(T) \cdot \text{Inf}_i(g). $$</p>
<hr>
<ol start="5">
<li><strong>稠密图中的弦存在性</strong><br>证明：对任意 $\epsilon &gt; 0$，存在 $n_0$，使得当 $n \geq n_0$ 时，所有边数不少于 $n^{1+\epsilon}$ 的 $n$ 阶简单图均包含一个圈 $C$，满足其至少有 $|E(C)|$ 条弦（弦指连接 $C$ 中两顶点但不属于 $C$ 的边）。<br><strong>注</strong>：对较小常数 $\epsilon &gt; 0$ 的证明将获得部分分数。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/13/%E9%98%BF%E9%87%8C%E7%AB%9E%E8%B5%9B2023_%E9%83%A8%E5%88%86%E4%B9%A0%E9%A2%98/" data-id="cm8ga9g1b0003ugyd45qx98aj" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-HMM-viterbi" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/12/HMM-viterbi/" class="article-date">
  <time class="dt-published" datetime="2025-03-12T14:37:33.047Z" itemprop="datePublished">2025-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="HMM前向算法-Forward-Algorithm"><a href="#HMM前向算法-Forward-Algorithm" class="headerlink" title="HMM前向算法 (Forward Algorithm)"></a>HMM前向算法 (Forward Algorithm)</h2><p><strong>初始化</strong>:<br>$$\alpha_1(i) &#x3D; \pi_i b_i(o_1), 1 \leq i \leq N$$</p>
<p><strong>递推</strong>:<br>$$\alpha_{t+1}(j) &#x3D; \left[ \sum_{i&#x3D;1}^N \alpha_t(i) a_{ij} \right] b_j(o_{t+1}), 1 \leq t \leq T-1, 1 \leq j \leq N$$</p>
<p><strong>终止</strong>:<br>$$P(O|\lambda) &#x3D; \sum_{i&#x3D;1}^N \alpha_T(i)$$</p>
<h2 id="HMM后向算法-Backward-Algorithm"><a href="#HMM后向算法-Backward-Algorithm" class="headerlink" title="HMM后向算法 (Backward Algorithm)"></a>HMM后向算法 (Backward Algorithm)</h2><p><strong>初始化</strong>:<br>$$\beta_T(i) &#x3D; 1, 1 \leq i \leq N$$</p>
<p><strong>递推</strong>:<br>$$\beta_t(i) &#x3D; \sum_{j&#x3D;1}^N a_{ij} b_j(o_{t+1}) \beta_{t+1}(j), t &#x3D; T-1, T-2, \ldots, 1; 1 \leq i \leq N$$</p>
<p><strong>终止</strong>:<br>$$P(O|\lambda) &#x3D; \sum_{i&#x3D;1}^N \pi_i b_i(o_1) \beta_1(i)$$</p>
<h2 id="维特比算法-Viterbi-Algorithm"><a href="#维特比算法-Viterbi-Algorithm" class="headerlink" title="维特比算法 (Viterbi Algorithm)"></a>维特比算法 (Viterbi Algorithm)</h2><p><strong>初始化</strong>:<br>$$\delta_1(i) &#x3D; \pi_i b_i(o_1), 1 \leq i \leq N$$<br>$$\psi_1(i) &#x3D; 0, 1 \leq i \leq N$$</p>
<p><strong>递推</strong>:<br>$$\delta_t(j) &#x3D; \max_{1 \leq i \leq N} [\delta_{t-1}(i) a_{ij}] b_j(o_t), 2 \leq t \leq T, 1 \leq j \leq N$$<br>$$\psi_t(j) &#x3D; \arg\max_{1 \leq i \leq N} [\delta_{t-1}(i) a_{ij}], 2 \leq t \leq T, 1 \leq j \leq N$$</p>
<p><strong>终止</strong>:<br>$$P^* &#x3D; \max_{1 \leq i \leq N} \delta_T(i)$$<br>$$i_T^* &#x3D; \arg\max_{1 \leq i \leq N} \delta_T(i)$$</p>
<p><strong>路径回溯</strong>:<br>$$i_t^* &#x3D; \psi_{t+1}(i_{t+1}^*), t &#x3D; T-1, T-2, \ldots, 1$$</p>
<h1 id="一种解释"><a href="#一种解释" class="headerlink" title="一种解释"></a>一种解释</h1><h1 id="HMM的袋子与球模型详细解释"><a href="#HMM的袋子与球模型详细解释" class="headerlink" title="HMM的袋子与球模型详细解释"></a>HMM的袋子与球模型详细解释</h1><p>让我们用袋子和球的类比来详细理解隐马尔可夫模型(HMM)的算法。</p>
<h2 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h2><ul>
<li>N个袋子，编号为1到N</li>
<li>每个袋子里有M种不同颜色的球</li>
<li>袋子选择序列Q &#x3D; (Q₁, Q₂, …, Qₜ)是隐藏的（我们不知道每次用了哪个袋子）</li>
<li>观察到的球的颜色序列O &#x3D; (O₁, O₂, …, Oₜ)是已知的</li>
</ul>
<h2 id="模型参数"><a href="#模型参数" class="headerlink" title="模型参数"></a>模型参数</h2><ul>
<li>初始概率π：第一次选择每个袋子的概率</li>
<li>转移概率A：从一个袋子移动到另一个袋子的概率，aᵢⱼ表示从袋子i移动到袋子j的概率</li>
<li>发射概率B：每个袋子中抽到各种颜色球的概率，bⱼ(k)表示从袋子j中抽出颜色k的球的概率</li>
</ul>
<h2 id="前向算法详解"><a href="#前向算法详解" class="headerlink" title="前向算法详解"></a>前向算法详解</h2><p><strong>目标</strong>：计算P(O|λ)，即观察到特定颜色序列的概率</p>
<h3 id="前向变量αₜ-i-的含义："><a href="#前向变量αₜ-i-的含义：" class="headerlink" title="前向变量αₜ(i)的含义："></a>前向变量αₜ(i)的含义：</h3><p>αₜ(i)表示到时刻t为止，看到球的颜色序列为O₁,O₂,…,Oₜ，并且t时刻使用的是第i个袋子的联合概率。</p>
<h3 id="1-初始化公式："><a href="#1-初始化公式：" class="headerlink" title="1. 初始化公式："></a>1. 初始化公式：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">α₁(i) = πᵢ · bᵢ(O₁), 1 ≤ i ≤ N</span><br></pre></td></tr></table></figure>

<p><strong>袋子与球的解释</strong>：</p>
<ul>
<li>πᵢ：第一次选择第i个袋子的概率</li>
<li>bᵢ(O₁)：从第i个袋子中抽出颜色为O₁的球的概率</li>
<li>α₁(i)：第一次选择第i个袋子并从中抽出颜色为O₁的球的概率</li>
</ul>
<p>这表示我们从第i个袋子开始，并且第一次抽球得到了颜色O₁的概率。</p>
<h3 id="2-递推公式："><a href="#2-递推公式：" class="headerlink" title="2. 递推公式："></a>2. 递推公式：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">αₜ₊₁(j) = [∑ᵢ₌₁ᴺ αₜ(i) · aᵢⱼ] · bⱼ(Oₜ₊₁), 1 ≤ t ≤ T-1, 1 ≤ j ≤ N</span><br></pre></td></tr></table></figure>

<p><strong>袋子与球的解释</strong>：</p>
<ul>
<li>αₜ(i)：前t次抽球，看到序列O₁,…,Oₜ且t时刻在袋子i的概率</li>
<li>aᵢⱼ：从袋子i转移到袋子j的概率</li>
<li>αₜ(i) · aᵢⱼ：前t次抽球，看到序列O₁,…,Oₜ且t时刻在袋子i，然后转移到袋子j的概率</li>
<li>∑ᵢ₌₁ᴺ αₜ(i) · aᵢⱼ：前t次抽球，看到序列O₁,…,Oₜ且t+1时刻在袋子j的概率（无论t时刻在哪个袋子）</li>
<li>bⱼ(Oₜ₊₁)：从袋子j抽出颜色为Oₜ₊₁的球的概率</li>
<li>整个公式：前t+1次抽球，看到序列O₁,…,Oₜ,Oₜ₊₁且t+1时刻在袋子j的概率</li>
</ul>
<p>这个递推公式表示：要计算t+1时刻在袋子j的概率，我们考虑t时刻可能在任何袋子i，然后从i转移到j，再从j抽出颜色为Oₜ₊₁的球的所有可能性之和。</p>
<h3 id="3-终止公式："><a href="#3-终止公式：" class="headerlink" title="3. 终止公式："></a>3. 终止公式：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(O|λ) = ∑ᵢ₌₁ᴺ αₜ(i)</span><br></pre></td></tr></table></figure>

<p><strong>袋子与球的解释</strong>：</p>
<ul>
<li>αₜ(i)：整个观测序列结束时在袋子i的概率</li>
<li>∑ᵢ₌₁ᴺ αₜ(i)：整个观测序列的概率，无论最后是在哪个袋子</li>
</ul>
<p>这个终止公式将所有可能的最终袋子情况求和，得到整个观测序列的总概率。</p>
<h2 id="后向算法详解"><a href="#后向算法详解" class="headerlink" title="后向算法详解"></a>后向算法详解</h2><p><strong>目标</strong>：同样计算P(O|λ)，但从反向考虑</p>
<h3 id="后向变量βₜ-i-的含义："><a href="#后向变量βₜ-i-的含义：" class="headerlink" title="后向变量βₜ(i)的含义："></a>后向变量βₜ(i)的含义：</h3><p>βₜ(i)表示在t时刻使用第i个袋子的条件下，未来观察到球的颜色序列Oₜ₊₁,Oₜ₊₂,…,Oₜ的条件概率。</p>
<h3 id="1-初始化公式：-1"><a href="#1-初始化公式：-1" class="headerlink" title="1. 初始化公式："></a>1. 初始化公式：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">βₜ(i) = 1, 1 ≤ i ≤ N</span><br></pre></td></tr></table></figure>

<p><strong>袋子与球的解释</strong>：</p>
<ul>
<li>在最后时刻T，没有未来的观测，所以无论是哪个袋子，概率都为1</li>
</ul>
<p>这表示无论最后使用哪个袋子，没有更多的球要抽了，所以概率都是1。</p>
<h3 id="2-递推公式：-1"><a href="#2-递推公式：-1" class="headerlink" title="2. 递推公式："></a>2. 递推公式：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">βₜ(i) = ∑ⱼ₌₁ᴺ aᵢⱼ · bⱼ(Oₜ₊₁) · βₜ₊₁(j), t = T-1, T-2, ..., 1; 1 ≤ i ≤ N</span><br></pre></td></tr></table></figure>

<p><strong>袋子与球的解释</strong>：</p>
<ul>
<li>aᵢⱼ：从袋子i转移到袋子j的概率</li>
<li>bⱼ(Oₜ₊₁)：从袋子j抽出颜色为Oₜ₊₁的球的概率</li>
<li>βₜ₊₁(j)：t+1时刻在袋子j的条件下，观察到未来球的颜色序列Oₜ₊₂,…,Oₜ的概率</li>
<li>aᵢⱼ · bⱼ(Oₜ₊₁) · βₜ₊₁(j)：t时刻在袋子i，转移到袋子j，从j抽出颜色为Oₜ₊₁的球，然后观察到剩余序列的概率</li>
<li>∑ⱼ₌₁ᴺ […]：考虑所有可能的下一个袋子j</li>
</ul>
<p>这个递推公式表示：在t时刻使用袋子i的条件下，未来观察到指定颜色序列的概率，是考虑所有可能的下一个袋子转移、下一次抽球和剩余未来序列的可能性之和。</p>
<h3 id="3-终止公式：-1"><a href="#3-终止公式：-1" class="headerlink" title="3. 终止公式："></a>3. 终止公式：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(O|λ) = ∑ᵢ₌₁ᴺ πᵢ · bᵢ(O₁) · β₁(i)</span><br></pre></td></tr></table></figure>

<p><strong>袋子与球的解释</strong>：</p>
<ul>
<li>πᵢ：第一次选择袋子i的概率</li>
<li>bᵢ(O₁)：从袋子i抽出颜色为O₁的球的概率</li>
<li>β₁(i)：在第一时刻使用袋子i的条件下，观察到未来球的颜色序列O₂,…,Oₜ的概率</li>
<li>整个公式：考虑所有可能的第一个袋子，计算观察到整个颜色序列的总概率</li>
</ul>
<p>这个终止公式从第一个时刻开始，考虑所有可能的初始袋子，计算观察到整个序列的概率。</p>
<h2 id="维特比算法详解"><a href="#维特比算法详解" class="headerlink" title="维特比算法详解"></a>维特比算法详解</h2><p><strong>目标</strong>：找出最可能的袋子序列</p>
<h3 id="变量含义："><a href="#变量含义：" class="headerlink" title="变量含义："></a>变量含义：</h3><ul>
<li>δₜ(i)：到t时刻为止，观察到序列O₁,…,Oₜ，并且t时刻使用袋子i的所有可能路径中的最大概率</li>
<li>ψₜ(i)：记录t时刻使用袋子i的最可能路径中，t-1时刻使用的袋子</li>
</ul>
<h3 id="1-初始化公式：-2"><a href="#1-初始化公式：-2" class="headerlink" title="1. 初始化公式："></a>1. 初始化公式：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">δ₁(i) = πᵢ · bᵢ(O₁), 1 ≤ i ≤ N</span><br><span class="line">ψ₁(i) = 0, 1 ≤ i ≤ N</span><br></pre></td></tr></table></figure>

<p><strong>袋子与球的解释</strong>：</p>
<ul>
<li>δ₁(i)：第一次选择袋子i并从中抽出颜色为O₁的球的概率</li>
<li>ψ₁(i) &#x3D; 0：第一个时刻没有前导袋子，所以设为0</li>
</ul>
<p>这表示在第一个时刻，选择每个袋子的概率就是初始概率与发射概率的乘积。</p>
<h3 id="2-递推公式：-2"><a href="#2-递推公式：-2" class="headerlink" title="2. 递推公式："></a>2. 递推公式：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">δₜ(j) = max₁≤ᵢ≤ₙ[δₜ₋₁(i) · aᵢⱼ] · bⱼ(Oₜ), 2 ≤ t ≤ T, 1 ≤ j ≤ N</span><br><span class="line">ψₜ(j) = arg max₁≤ᵢ≤ₙ[δₜ₋₁(i) · aᵢⱼ], 2 ≤ t ≤ T, 1 ≤ j ≤ N</span><br></pre></td></tr></table></figure>

<p><strong>袋子与球的解释</strong>：</p>
<ul>
<li>δₜ₋₁(i)：t-1时刻在袋子i的最大概率</li>
<li>aᵢⱼ：从袋子i转移到袋子j的概率</li>
<li>δₜ₋₁(i) · aᵢⱼ：从t-1时刻的袋子i转移到t时刻的袋子j的概率</li>
<li>max₁≤ᵢ≤ₙ[δₜ₋₁(i) · aᵢⱼ]：所有可能的前导袋子中，产生最大概率的那个</li>
<li>bⱼ(Oₜ)：从袋子j抽出颜色为Oₜ的球的概率</li>
<li>δₜ(j)：综合考虑前导袋子、转移概率和发射概率后，t时刻在袋子j的最大概率</li>
<li>ψₜ(j)：记录哪个前导袋子i产生了这个最大概率</li>
</ul>
<p>这两个公式表示：在t时刻，对于每个可能的袋子j，我们找出从哪个前导袋子i转移过来的概率最大，并记录这个i。</p>
<h3 id="3-终止公式：-2"><a href="#3-终止公式：-2" class="headerlink" title="3. 终止公式："></a>3. 终止公式：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P* = max₁≤ᵢ≤ₙ[δₜ(i)]</span><br><span class="line">i*ₜ = arg max₁≤ᵢ≤ₙ[δₜ(i)]</span><br></pre></td></tr></table></figure>

<p><strong>袋子与球的解释</strong>：</p>
<ul>
<li>P*：最可能路径的概率</li>
<li>i*ₜ：最可能路径中最后一个袋子的编号</li>
</ul>
<p>这表示我们找出最后时刻哪个袋子能产生最大的概率，这就是最可能路径的终点。</p>
<h3 id="4-路径回溯："><a href="#4-路径回溯：" class="headerlink" title="4. 路径回溯："></a>4. 路径回溯：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i*ₜ = ψₜ₊₁(i*ₜ₊₁), t = T-1, T-2, ..., 1</span><br></pre></td></tr></table></figure>

<p><strong>袋子与球的解释</strong>：</p>
<ul>
<li>i*ₜ₊₁：t+1时刻的最优袋子</li>
<li>ψₜ₊₁(i*ₜ₊₁)：根据记录找出t时刻的最优袋子</li>
<li>整个回溯过程：从最后时刻开始，逐步向前找出每个时刻的最优袋子</li>
</ul>
<p>这个回溯过程使用我们之前记录的ψₜ(j)信息，从最后一个袋子开始，逐步向前找出每个时刻最可能使用的袋子，最终得到整个最可能的袋子序列Q* &#x3D; (Q<em>₁, Q</em>₂, …, Q*ₜ)。</p>
<p>通过这种袋子与球的类比，希望能够更形象地理解HMM的三个重要算法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/12/HMM-viterbi/" data-id="cm8ga9g140000ugyd6zg67hzr" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-独人脉感想" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/30/%E7%8B%AC%E4%BA%BA%E8%84%89%E6%84%9F%E6%83%B3/" class="article-date">
  <time class="dt-published" datetime="2024-12-29T16:15:10.205Z" itemprop="datePublished">2024-12-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>1.人脉实际上是需要经营的，不是说谁的感情好就可以，这个是一种超高智商的铺垫和做法<br>2.人脉要看这个人能不能为你带来实实在在的利益<br>3.人脉，最惨的是他卖了你你还在为他数钱。你真的有多牛逼？你真的以为什么事情不会降临在你的头上？<br>4.如何让你的伯乐帮助你？<br>5.想让人家优待你，你必须给对方台阶下<br>6.人脉关系两个层面(用得上-&gt;合得来)<br>用得上不仅仅指的是级别比你高的！而是对接的上的<br>维系关系人脉最辛苦！<br>一定不是说饭局好给别人的利益而是相互赋能<br>利来则聚，利尽则散<br>没有铁哥们！<br>资源差，信息差，认知差<br>资源差:给了我一个项目(变现能力最差)单项思维<br>信息差:知道 这个人说话没有高度,有高度，听不懂(对行业的认知，解读政策的能力)<br>和之前领导</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/30/%E7%8B%AC%E4%BA%BA%E8%84%89%E6%84%9F%E6%83%B3/" data-id="cm8ga9g1b0004ugyd77612sej" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-受辱感想" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/26/%E5%8F%97%E8%BE%B1%E6%84%9F%E6%83%B3/" class="article-date">
  <time class="dt-published" datetime="2024-12-26T02:33:00.205Z" itemprop="datePublished">2024-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="我对于这样的事情暂时还没有什么更好的处理方法，但是隐忍，最后可以一举歼灭。"><a href="#我对于这样的事情暂时还没有什么更好的处理方法，但是隐忍，最后可以一举歼灭。" class="headerlink" title="我对于这样的事情暂时还没有什么更好的处理方法，但是隐忍，最后可以一举歼灭。"></a>我对于这样的事情暂时还没有什么更好的处理方法，但是隐忍，最后可以一举歼灭。</h1><p>我在想，哪些看不起你的人，绝对都是有着双面性，他们希望<br>工作中的关系，似乎被蒙上了一层阴影，但是这种事情<br>我本来想贴一下这些聊天记录的图片和他们的家庭背景，但是想了想还是算了。<br>在工作中，你的关系似乎蒙上了一层阴影，其实本质也是人看不起人，但是你的工作能力，机会，会对这些东西产生影响和加成，让你看上去似乎处于开挂的边缘<br>在普通的人际关系里面，他们没有时间去了解你，考察你的情况，我们在面对别人冷眼相待的时候一定要保持客观理性的面对，特别是一些所谓有着家庭背景的人，其实很可能看不起你，他们似乎还想让你作为他们的舔狗(虽然大部分女生没有什么背景的敢于这么干的直接就收拾了，但是一些有背景的人，)<br>我认为先不要考虑这么多，他们是家族的废材，我们不要接触他们</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/26/%E5%8F%97%E8%BE%B1%E6%84%9F%E6%83%B3/" data-id="cm8ga9g190001ugyd7ctfc7nr" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-我们该向何方" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/24/%E6%88%91%E4%BB%AC%E8%AF%A5%E5%90%91%E4%BD%95%E6%96%B9/" class="article-date">
  <time class="dt-published" datetime="2024-12-24T07:04:25.982Z" itemprop="datePublished">2024-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="考研基本上结束了，那么我们究竟该向什么方向走呢？"><a href="#考研基本上结束了，那么我们究竟该向什么方向走呢？" class="headerlink" title="考研基本上结束了，那么我们究竟该向什么方向走呢？"></a>考研基本上结束了，那么我们究竟该向什么方向走呢？</h1><p>从这一次看，我们看上去可能差不多一点，但是在其他事情上面，其实人生更是一场马拉松，人生的评价标准更加多元化<br>虽然人生似乎好像没有类似于考试一样那样的刁钻困难，但是人生里面在关键时刻其实更加具有欺骗性和难熬<br>考试本质是一种筛选机制，我们通过考试作为一个公认的标准来进行资源分配，而人生其实本质上也是，是一种手段无限的，其实人生也在人类社会也赋予了若干标准，比如你的学历，职称，行政级别等等，这些”公认的选拔”通过一系列标来进行筛选，而人们也向这些方向进行努力</p>
<h1 id="外部玩家和内部玩家的区别"><a href="#外部玩家和内部玩家的区别" class="headerlink" title="外部玩家和内部玩家的区别"></a>外部玩家和内部玩家的区别</h1><p>如果想要平凡的过完生活，我们可以得过且过，但是如果真的想爬上顶端，我们一定要明白任何一个规则制度本质都是有后门的，你必须成为内部玩家，你的努力才可能成正比的转化成你的成就，当然外部玩家其实也是正相关的，但是这种正相关会是极其不确定的。<br>你或许会说高考就没有后门，其实后门就是你的习惯，智商，好学生他们会很容易的建立起知识体系，并且实现一分耕耘一分收获，但是大部分正常的人，就很难实现，而且从外部玩家转化为内部玩家是极为困难的，因为奖励来的非常不确定</p>
<h1 id="那么既然如此，盘算一下自己适合什么"><a href="#那么既然如此，盘算一下自己适合什么" class="headerlink" title="那么既然如此，盘算一下自己适合什么"></a>那么既然如此，盘算一下自己适合什么</h1><p>对于我来说，我认为在学习和科研上面，我可能是内部玩家，我可以适应许多困难的认知鸿沟，但是在人际交往的地方，我不认为我是内部玩家，虽然我可能有一些比普通人强的地方，但是在更多的待人接物，迎来送往，我似乎和最顶层的人差一些，这里的天赋可能是他们美丽，帅气，有好的歌声，跳舞，但是自己或许在一些事情上和他们付出同等的努力，也许就是达不到他们的高度，这是因为自己先天或者说一些本质的问题，或许自己可以改变这些本质的问题，但是我们还是和别人差一些，这就是或许你的主观意愿是1000，但是你的成功可能只有10，你的杠杆不在这个行业</p>
<p>所以在一些行业里面，比如当官，当学生会主席等方面你如何与别人竞争？没有人告诉我，但是我想可以这么干:<br>1.使用自己的长处来补齐自己的短板，比如自己擅长学习，那么就通过这个来与别人进行交换，去认识一些擅长干学生工作的人，去找他们进行资源交换<br>2.也在这期间不断的学习，补齐自己的短板，在他们的身边学习如何去做事，并且使用自己的毅力来保障自己从外部玩家向内部玩家转换，相信自己有朝一日可以替代。但是一定要保持一定的度，知道自己到底应该干什么</p>
<h1 id="在科研领域自己又要干什么"><a href="#在科研领域自己又要干什么" class="headerlink" title="在科研领域自己又要干什么"></a>在科研领域自己又要干什么</h1><p>1.将学业搞好(其实这个是次要的，首要的是科研)<br>2.将科研搞好<br>3.在以上前提的同时要积极接触竞赛，还有积极的认识各个领域的青年才俊，为自己的将来铺路垫脚<br>4.接触科协之类的社团，练习组织能力</p>
<h1 id="还有什么"><a href="#还有什么" class="headerlink" title="还有什么"></a>还有什么</h1><p>1.体重！一定要保持<br>2.健康，要保持健康的作息规律<br>3.运动，健身，让自己更有活力</p>
<p>说了这么多，其实只是一种大方向，但是具体的实践还需要自己去躬行，积累经验</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/24/%E6%88%91%E4%BB%AC%E8%AF%A5%E5%90%91%E4%BD%95%E6%96%B9/" data-id="cm525m8ge0000g8ydf8xj9dib" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-读史感想" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/23/%E8%AF%BB%E5%8F%B2%E6%84%9F%E6%83%B3/" class="article-date">
  <time class="dt-published" datetime="2024-12-23T12:17:30.000Z" itemprop="datePublished">2024-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/23/%E8%AF%BB%E5%8F%B2%E6%84%9F%E6%83%B3/">读史感想</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 最近感觉要记得东西太多太多了，也许人类就是不断适应痛苦的过程。所以我希望整理这些东西，形成一些记忆，以飨读者</p>
<h2 id="毛泽东的三次思考"><a href="#毛泽东的三次思考" class="headerlink" title="毛泽东的三次思考"></a>毛泽东的三次思考</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/23/%E8%AF%BB%E5%8F%B2%E6%84%9F%E6%83%B3/" data-id="cm510c1a20000hcyd190bccop" data-title="读史感想" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/23/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-12-23T12:11:44.115Z" itemprop="datePublished">2024-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/12/23/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Hello this is a (static)Blog of a student in BIT(Beijing Instition of technology) and will write what he likes and something he learns</p>
<h1 id="contact-me"><a href="#contact-me" class="headerlink" title="contact me"></a>contact me</h1><p><a href="mailto:&#x64;&#x65;&#110;&#103;&#104;&#x75;&#105;&#108;&#x69;&#x6e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;">&#x64;&#x65;&#110;&#103;&#104;&#x75;&#105;&#108;&#x69;&#x6e;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a><br><a href="mailto:&#57;&#x37;&#x32;&#57;&#48;&#x38;&#x33;&#56;&#57;&#x40;&#113;&#x71;&#46;&#99;&#111;&#x6d;">&#57;&#x37;&#x32;&#57;&#48;&#x38;&#x33;&#56;&#57;&#x40;&#113;&#x71;&#46;&#99;&#111;&#x6d;</a><br>my qq is available all day but gmail may take longer time</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/23/hello-world/" data-id="cm50zyu8n0000cgyd0bz2evk2" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/22/ROS_%E7%AE%97%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/03/20/%E6%88%91%E7%9A%84%E9%83%A8%E5%88%86%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/03/13/%E9%98%BF%E9%87%8C%E7%AB%9E%E8%B5%9B2023_%E9%83%A8%E5%88%86%E4%B9%A0%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/03/12/HMM-viterbi/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/12/30/%E7%8B%AC%E4%BA%BA%E8%84%89%E6%84%9F%E6%83%B3/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>